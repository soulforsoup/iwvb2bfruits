<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>IWantVeggies Pricelist</title>
        <link rel="icon" type="image/x-icon" href="images/favicon.ico">
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 1% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #009048;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #009048;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #FFFFFF;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p style="text-align:center;"><img src="images/iwantveggies.webp" alt="Logo" onerror="this.onerror=null;this.src='images/iwantveggies.png';" style="max-width:50%;"></p>
                        <p class="staticrypt-title">Wholesale Fruits Pricelist</p>
                        <p><p style="color: rgb(170, 170, 170); font-style: italic;"><small><strong>Call or WhatsApp: <a href="https://wa.me/6587680491">+65 8768 0491</a></strong></small></p>

<p style="color: rgb(170, 170, 170); font-style: italic;"><small><strong>Email: <a href="mailto:fresh@iwantveggies.com">fresh@iwantveggies.com</a></strong></small></p>

<hr />
<p>Prices are subject to change without notice due to market conditions.</p>
</p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="template_toggle_show"
                                title="template_toggle_show"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="LOGIN" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = 
            ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        ;
            const templateError = "Invalid Password",
                templateToggleAltShow = "template_toggle_show",
                templateToggleAltHide = "template_toggle_hide",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"8ca2a7e98b83de5c212016cc75fef5d8f4cccf5560a58b442e9d2c15333acda6945ca164a2ecd3f5b737474023aeb3d352275f0259c7b683164f5123c415d990d0b2ac58aae50d29d8cb223a1c8af9f16546f39b85d5e779d4630525cc12c3bb8b358a9b162954108489038ae3c554a3245dad083452fea842d48ad1ca8b8d10f0186e9b8903af284f4ee14fe811287c12a6fcea9b39ede49efc42ea5c49f5a1d35f77faf8833240e05a802061bad7d6da306191e5c55532d96ca4684e69e468af31ec5182acae087cbd333a24cc65c433b7a467147ca2f194dac6adfdda52bf19ed740ec89cf91610687f24e5eba1a78f83ba03579438367651f4efdb6f6ff6d05cb1e168766b5713921bb5cd3d76cc2a886e2fc9aee7eaec6581421e1ccd4e74f41131ace47ba1ee3e0800672d1163b762e2fabba74682caeb800830fb6f972a1a168b361dd3bf4378e924b2215bbfc4ba8c79c2d226fe1829a51c2bd876b66ca0de8e323da306b441b472a90c7780d1ce6f8aeb40689602f15628b03b95358aade94f4b3220f1cd495f5301f5005a7a4ac58cdd6a70bb2a68f2da941e9568df4413c01f95120b184bffb19faf4e0b50a24e05a4593875616a872feba09fcb888fcce3775fa72be43dc6800e0f9418edf2f265db2ed8e0e9309b930d10c6ffd8ebe72fedc8893110cfb423666bee4849a6fabd9c7f905c66df798f37cf8c9c8f061b1613040e195f4c6ee544a9c21406009fed1fce3b032cd8028e4422460b958ca35e8baf5414e6154e5a8113d4d53e05895acbe44a443fb57823594d5a7c23ae537ff380d5b4c1b2afeb5c877baf4e0fe7436611cb31d70dffce2fa988ff6233c484e8d11928283ce46b53c627895922aee20940f6dbcdc9b572c3afba4946aa4e65f435c1218edc76a38aca4e3365e7ea479c7606c44eb023a580628cc5dab2e7fad482aac0bf15039cb7ae15afae3948251abc81d59d60371b1fd4fdb659d9d5147bccfcbcab252ce66f90b482fd397d172ea3c8503ea4eba8ce3d5fb24636af1c8e8e793d6345c1252a095c0cc09fcdf6d1007cd81104cbae0a9dace84a313377ff4ca25d9b7bfc8050dfb08597d38e4116f55e20c55408e7cfa71da960bee113ee44813fdebde4e8c4f0a511c27ad7cceef2b379ca4327593dae1594eb9b3e8a9bb8e60c947a91c0a2868e61e2f6daa34909d874b4596463c2638e7366826ecf1618ea7f02fa4d9965d415a540e53231385ef9aa511bd7f0b87fa4d7dd2b0d0cb692c29c2316eedc328a1fa4c4ec43f64c4dd28afab3f7953a0a5506d6e968af5219d6e1b0c1854c0bf3e565bfe6fff343a73a3b9f399d876ee2df1f7b321b1365aefbb40d3aaa8f25a9a355ea2951b5f2cb07b02794f5c95b93f2efbc077b22b9a284380971c1102f9fc1fc97f2bb0e58c0e65b8ad8771c7c916029210c8f80ff412562b063f7e4166af34fc82b8fa50fe738462eccdab56905479dc9053753f34dbf9f4e6789c659683019ef2e9649d2f70fdb105e78a7f654b66c03549221e00b71bfea55851912be03ae3e32c268133705208e4e8bbb653a9d45163f18d93a91775708b420e9b25ff10fdc5e9a444492b3b3ce84faacecdf38e0d5f82aa9625201f49115f0ccf4252c2282ca6b1bdd92cfd56fc89e05bb95df47024673235d6fc47b2e4a1bc75a90d1c359e0e57df0e57a9594630919ca2c9c5157fdd4bbe6f5c8734e642beb8f4262f34f7a1cf9032c074246f1e2d86a666eec1149de7a5aa464833810758849424b1157cc0fbd9174493d7fe0e248cfb608bf302217474a5a7bb7350748d662165b151038a21d95c500cb32efb9ca993de821ab138917112dee591d77a4171a4b2d229295858903a53f95544ec4ca05a9ecd4cc5e4b2783ef3d5e58a6bb35e903f9221e86370205ac64c87bdb28167cb78145b00b68f039ff179643f23f8aa9f76c7e21baa4bc27d6c7b2657eb4f3ef55469bf03267839b6f6bb66273e022c5b12bbe65a813d429210e08e6baaaba25072b201bc7b48690016c94d13d135b820c9f574fd7164871e7c674b9412acd8ee6fdd47a6af219adc25b731482b75dba2c979d27da8811af7d50e13ae607301f4cfe04f63a828af315617fd6c391f1acb4dcb98414a1f3f49b8b6fb23f9b3d650413a7b9ab8daaa3cafc547002a1961cef1631c6ffabe0d64973866879c29f2f11f8e289eb718267cf93ccd8636c90e73a4ff02e149517e2bc0dede762cd92065c1a7e8fae21a5cff815a1c265d09b97fb4ccc1c9cefcfe2e62d27259e5325c2ef3813f37b42aec54afe7753a87859679be6879e940a0c30be41c4a4cca8357ca1d8b8c5fa4b9102b191eec4ac2bfee42ff64cf9cf53f34590d4a1e05271469fc7754427843aaf8ec6b222a8c262104c844838d4b8b55a8f7dc9bd673b0b87e75c4c1c49f9240e28199c6d1b99d8920978fdb409a3d12e330995be8e378ab25531fa59e6dbf28854c7c3f4fcc349c69e1af528e5df8c88c9c8bec624b68f2b242add864525c14fa36464639b2d8101b6982b748485bbe45afe47e9072483d245f24a149554f8e34816fa18238b822717e4f0718345d67af14ebe4c0fec30f7088ad5665462d188d71890d260bb321d59801887d23b24e6b359a45dedb4a936b404ef9f27ccd401f831dd616ac901a00f35cdb6439cd69128edeadfe6342edb291d3fcce0d5d3dde94db4bfe55c3a1c374132717964db0ce50b74d4df9eefb1f388cfb49af6514b53f80a6eb7276cf359465f27f43c8d095f1974ac4db0b3fb75b3cbe8eba9c1a65792a0cc4d646e6f8162814d286977d4056f8596f3f510e1c0564896d22a20d3d5bc88f7edfb34f956d9668ec7d0ac314458e198d5cedd7fa3e676d9761c06693cc485bc719fa09d6a9016151e95fa53cbfc740d1055e5afa7493253f0b83d01c009acf4ee29277f8114e8f314f6a0677eab2b9d4cc05f78757b4f6334b60a1713997678b763d6dee8b3fd3e63de3da56f1bbf3a745d439c6474e64fc0215d70173bef3e6c28a2057adcc0f370851ccc857aff0017043bda8c13e0f6a28cb3c645bcb839db073dda9f05c3d0bcf2b4a928b90836266f1cf3c64ac94b7d8bf4d430e357ec9aa8291bb29422c62a3c27b4d5e18e92f38b337689b28135c5a22c199708d1c18d56ac16f734cacf884fd5d9bc9ee888618ef980fbee7db3895152944aad64b1a2bf3c91671484ee1dadf4a7ddb069f67ab8cbf2ff94bbcd8cee103169e45fa149b54c511741aee2d895703987466a692c661117715cef0f206992afcc86ed6cd8d35ee5a20499e02bef8900a1a48a735035574d609727750b5a4c70efcbb80eb7a07630cd5a24228e9b184be5a6ab8d5f54171f73316aca03108010c9a127a50a5cbf299ef4c785e63fbfd3a3d3607b9a7454b14bfd5bbca76a59d6fbf9011fcd12fd66878d55f029320face2a7ab16076cfef8c543d1a89cb56c7d9404e4f13fba2e06a8bb694190e3539515533cf9a7ffa55a56dc648604465d80a86066060c82761364535c23ca0d7ed3f787b4fd9498a0138737b98a685359e24f849b68db6ea9f44ec3a9216ad97c32fec72526915980270d49b54387eab9a18bf875e4c5005836f0e7fecfff48908af6fc7830d8eab4eef5e03f547cf116c681b9aed477c45d93ab8498268f75ee4e7fb54871e78640db4f9b34507a2cf79fc9953ae5a006f897c4a368838f67c87bfe3c16648e919a8e5dc6904e90363aedaf853fa08bb64f520ddb110c8910251a367ffb6550fb4c48d4d80d4e7d8261506e42221f132bc22607ba3fcb94641cf97252a97b01cf18989cb3e5460c40291a6ca814ca60219fabd54fb47f6365f273f260cd03e01d777c4d41c0ba80ba97a412c911301355b75183adef472ce39b1657d5d32675e14dbba6255dcc1220e1fe97628e3159ac673ad0080ec3705bf8c3f5b746e0784dfd3cd6f664b0c18597a5794ce3b75ae832e06c5bf3f9c3a635829e6dda1b02265d52ccec2e7b499f918962a8dd92e49aa9fdbdfd83ef1347d4ee2efbb24c0f74c1a3fe502d309433cd061937778f931f889b3a95a5c9d53a520b351553b15926f03f79f8f20c4e24f7ad7325ed4a42c88ff5dfb19f934b1a61dc0a6c7df8d32b0fd512689b06bb5baefd71fc471bf57eeab5d105dc286f5f55703c88a0e0c62f97699ad1e01d9fc87c13ee5635a47668403cf598b810e5abf9d95020adc773765bd1c1c346974ba296634e912d9a2bca41d814f1182b2db747d85665eb6dae7080b4d51eb0a21e1b129eff541f53802a8cbaab227c1f10ab063760e8564f5a57e61fd6271ee05447f3b1d7d197370bb7b592874e8585800a47736c0f469d74f6b25149eecb75ba1a637f2525131ad2e0a08038834c237df7a7a3e6d21770214e3061efde76ac87bd214164b9f916b748600520bae70b0fb4218734cd47579946d894bc6b03be7d6e1d4ff316bfe783d40970ae1e693031c5bec9ca1085a4ed77af5590209ddc0e1142a2c380112b14df4c4ec80d4ad6d8d3f578be68c748110b56c8cd55c592a5cdd302ccf5b215ca4812122d1fc559ca9f5e94f3b574f442eea354d478a8244978df07348daf7bf63729472814d7e3bb0e6c90ac7cd2333ec911840b00a9a486da3a224cb858a112117077985e61a0fdea8203723288fe6f5196a56318de40146fe69c2abe89c3a95ceb75125a449f0f1638aa3e0a3688c9bdbf40fd81489d11ed013f19627d0683b16da8c9a4c6d7a5db3220ae11ab24103dca6de3d04ddf8cf891a34f39c0418a4f725134c36fc8f563e283c540fbe26a132a4f51efbe8ef9e912c19eb86dbded8d999bd2c47faad0b71eee256d030afff132c4c80f96b2a8d39d90c16485f02ece13a5ac5d8d0f18c8b5a092b653b1d96a2f516013742f02ca78fd730255b22ce6d5ced0fa3a9cb747ee8162f65d3f44eb8cc53a2804b6c857b2385c209240997f3974cdfb1f5a260b6b7da3350e984bf571d6436a29e144cc86cd431102cdd1e87b88e690fffcf7ea398c34e21eac5d6dbe749209fa8d2dccaa5b26fe2d6365fbe56e4bda25dfdc430722264c396478a20370f74fbfb14e495cba67888594ab0a9b61d2a3a467bf1f99205a85ff304cdc11a33bb7a035fc2ecf96a81f7dc48fbbf8078ff39f7e7be203a777139e39e0cf119041119e60658a3b62b1cc7a6c27d5064aecc262a004db5f225ece2a7e805666ed97120714b474cd8f474d25ace78ca28d1073e494220a6af969d05d6cc7fe63d76943192028c39b6a821b8c490223d8b092081490462260250f77ca1da0b42b8b5e2525b1dd213d3acb7a3b3f600f1ad00fa30d08aa4fc82c0f2e3decfc2d06b4621885af8c14999df5accd7df7413c5f6ab3a619af9186e301fdb1dcec8b797c0e046e40f48d3b463f6b325b599f563bcf56b550adcc41d1f6a0981185d0f4f67d9fcc24bdded11b40a6f70077947ef7a848e078676c9142e928f4d445b893a48f0bfb05b5429ab99ede1bb233afb45c1b793891323f401d42844a4d2974f194be55a2cd4efc927ce98d3f3a02ead668881098f68c23e9866e761a670546f1d0ec264753afd2532de63888ba83f51a9793c2b27e1c3f97814bb16013e631fee4a392abd4162ba70c6333c50b2ed1fb7e39ab34531fcb5556a3c5fd1bf781a079edf46105626a6635322c30feda7ccd79de01ea2887ac49958c4b1c09136a7610d756e5febd29a2d81f5f3e79193509e48c485e1972ffd119824ae510b3d456e9579255364f4a038fe2f0c34c3b809fa4da4684e6b2ffeece3b681c47f5d914e76585e28f058d731bc895ecd61f2d9fbec2a6a7eee571de18dc7fd7c90980dba8ba5f5c5221a372c5646211a2fe11a235893eba87fcf226bc1610cfc3def170e8ea0a65c84f72e661ab8be8ca81bc53fdc2ea339400d40405b0471b745e28ec6f2881c2ba206d8799937f4a238d2e7a609722b199cc3aeca2724418839de903e325b90df3d9861630fafd4480ea2722f4a2cc3865b31c15da065429187385f60a8b73f9639e3833a18303eb6da07fd017601d4fdfe469d1a8e52ee2a778f23c0237d93eab9e8d93d0a11a836399216b7071d3df469ac3922b4e1aef51d108b30f9e573b7f6eab9724db55373c4f6fcb8e3dd9e06a62453c240901d8e06918af424e2a643ebcf71d8a25af6043b3b398029f5fc4e56c8e8c3d3a451cf8a47058b997d3fb582feb7689c2e79cd364f998bb224d846de08344527199b119429735780f6075ba0556f640babe4ac72a86a6b5af14ba3a23afbf9cf44294ecc999ac4c1dd5a33d69fa76d10b6438b4f7f91e680e428b7018da2afa50558c8ab907eb24c8abb64d43779753ffcc44d76dcb1b23f254024c8b56dc151f750d1142577236d572f43ee7924b8119570949c020aa25880fc0736e11448a494bab63b756b59df87b705cece16d45fbdf895a4ae46e0c4446ad41c86710dd0d579e57734090574ce7a9df6849f51b4fa208390222ec4a3604ec86e6a7123d82f92c88b7c19f0b3e630876c59d87b63ac9ff4aa0b3562b65c9f4ee1bc57e84212cf553f475f3656a3cd49068bf0e33250a4d3ea4a020366eb66f238f0173868d03a02a3652f18c02d5f4b53d290207deb8296002bd3f59f9dfc5b6a2e874c2636830f9f3373b08c383571298f398f2fd1b5259ef2edb5cb12e4e995a4e6c2ad24f6aff46cff4508957ae6989b9f5d233f9552ba33d158e731352b3334b67c746aab60046486cd88a020f26892759bb181b49a5cba75f7b022d955fbae597182189e113d395cce714f2706f2bc20e26bc99acc99987cf46f3d653fa3eadc9af2b15543113c926577dfc23710ec8c9e369fcdd4564775a32843c132fb822da94eefb3ac87bdb8b09a66e8e4f2f0153cfbbbf09cf4a6c272698e280724b389ef259419759c50b90a1d3363ec74594d843351d80cd7e1448de949b29f4e91922a156cbfbb633bfdeb42cb5e5caa9744fb2b0614e4aa6a2cde5973bcd825c17585c9a9100c86409ce15c58abe1dac142f61e22f65e2e0a9da3c3a0809893c2e46ff232a6cf5eb57e1a66aa0175f8f29125ccbabe82384692ce27abd1a60c15d7370cd095634c0a70c005d1114932c52c08b94bb63497ff84bcbddf19c1bf818c0886d882c1594b617186a17397f0e0b1f7d26586b963531db38d1c74e5f8ee685b952291ff9aa145e6413d72649154f0fd8f03d355e3475d4b73451999fc21149fdc198cbaa961958f294add0090e65f9c1e9c4536de9612a5b8cf8ef7dbf065893e7cb07f665edf3073f4749da62cea1f537e6da8ea7c50f96f9797a1c176b98540f5385ce5ec461da121ba797ae7a1c1e413b364d55072d6827499b301cae94bb4d8681869347c05ba5ebc4b93522bdf4cdad2e13b05af6979412466236d9a21e5afbff633e1ad06aed730b384a84b90ae52b0d38641b90e457df622130afe7701cb6c7ae0b0f7ee8fb0eb156083094f79d25097e6850b790277b177db23047c9492efdc073a743ab502d18ec7b7eebf88da11dac199e76847b045794b0834ade6a3a4d881ee456b2162cea73b65d401fca1e5f88e06a5c04c97e2d772fc2d42a19f1ebba732518448b587a62f8d420d8a7bd4134f7e98fa1aa45ddf27dc9ba6ebf7641310e67b0db3781f7db85d15c37e189d0f833a0ee3f82ee4d1752f80a281e0b9a3af082e7745bdbe7528c58dc87c364be01470c0363603cba3ef23d220fb073b43b28044762d3b20fc1fd6660eb4d7fded7f41fa20829ee16f8a94a15ae72a5d62057a333510a37dec7742dc49719cdaafb5770bf277f31fce5e0aeb11d962d2f842c9b8d58bfe00230b3c1680405b91201ae8205cdfa208cf628518cb31250fe6cb32ee94e77089556b59a28d51bf3af067207bdb87e611c9ee562521c1635125e567617f3c64447de4704dba252f7884973fe1de5e95841cee4a733f3da3c4b547c8d69b373676bf30e73fe54f7f30a54b03fcf834075d346e5593da80ea138d54981fb15719c33d8a29adb6e90dafe6e276d7e9ef8b8036beed20cda83b4461dad347571802eaae3d3c6c16a1b32eb9b166508d2ee5dc09060cabf626d1681edd3f627a2da80a51a308959db9dfb69cb4eb6cd45bd6f48ad65b6fd514a392026890013905e013922c00f6121747fe7c83586f95f24ed51bb26b2af517ce3a14f38c5684f31b785a45c0d707d0829fdff2b90f60ac385549b16ef97592cdb94ca193d31f35ebc361bbd3ed48448f5e7c2663f7aa4101b610902dbd7fdb498b8b6d33fab677d05edae405a4b44f0d0a51af668a481e3e293ca3b2651b5ec507a7fc175992e804f97640356d2c77d87c19007550ae274ee3101cc9d884025e9be06f02527ad0e59cd703b7cf014ac1ea29c7398cabb43c579244e55abb575ecb4f321154592332c294afff325673f6f2c86db45b35b29eb36e2da6af1d552fdf63fbc3910040934a7cb8b24e336ee743c91e6c4c736caea5f6338df30c40a57602813691fe3f0a0c491e4940a57a0e8059430652579e252e0409cd621c1d8f4ef08edcf97eaf0d29bc81d9ebc4fff4bf134b11160abbb2aed612ad3710fadb40db15562767ab62323fc9e2e6695e1c4ede9c8d1229610d2855607d60fea8334f0400b2a1b46c02420a6fd46bdc7b2f1fc1b2bafce72192086c823f58e0bb20d0e1de04a053686617245e473544d39af52f9fb2d54cf84e98767f5447cdaf9aeba39ef2c091f439a7a450f811953c71b87f4cee90faf3f6d25869a1513aa9552d7df2e37f8a3d3bbb4d5cb09cf51f1bd70e7d94997b0aea7cfffeaa7819334a89470395df608944b2a6a7ec06966a9c12a58f8d1e1058e62e30550be892dfc37a24ad89d5ca261f95fc4a3eacc34caa59969247c5461e90e0e830487896ee6ee65036909b0c19ed04f643601694895ace29fe92a5c415ff802bb03878dddfe5b865ea9728353a574bcb49d107ce2d1cc9475dd132a3704cc1844cb5173e147abd5922efa2da1fc4cbd7675a3a2c45d6a7e6bfd150c6941fddf933ba7d4a083c744efe571fe5532483e954929f3649bbd91e024f0f42d5bd0c1e6d93da8fbd651ae6fbf8ae29b79939529170924d442564412375c95f6c31e1bd0a0dc83eb51a3a276340528613d6efd71cf527e5d5cd4ff9695e5618d130d014fbd60751dddcf460128cf04f83782bead75ea658b9a4d248fc9b2388b57d2375316e5d227e0baeddcdab249fdd9952c34220459660fc0c2fb0c5c1a21e11f5a67d02b1372ffd07007a38009bb7efe4ea538ec2d17f2fdcf16bebb91df8ba6479b6917e25a4ed83337a5b1ff59ba5e3ea0db946d70336e91063ffd988b633641fb04a5d01b2be28565fb75b594f518286089f4cd3c26a884411c10ac256f06966582d4a0e99af1e15c56ed718e870ccf073a3467010d9ce760a68a41e053f94f96e2bb77b031a2361243b2cc35d0c4674624e5fd7dba1f077fff093238bc788e509049ba489a830e0716482f89921c92ca1188f14ab0e5fa5d369805095a929734d3135cf474316c0d728973d41baadeb8ea166164b202b6f206d1d2590a817dbede93ba27b002770916b2c533b1da2b239b35a6dbb2830cd7e7550c6cb9ed2e0034c0778e619b5ed1fc885783841c000ac49785efbf95598a3f6627b779db0251f0f1052f36245bde57d2bef24cffe9311d35b9fe8dc7dba06823ccfd439d1cc2b305356d739850a0f3738b1faf86121ee9d6bcd7484e8f2038fee1110d904ef5cf1758d7022194483717257011994949b4cb199cdb7bbdb701aa1976fdeab912d7f56beb844cc5e20b2c70558943322b78fd4bbf26c5ff6908e835b5cfad2762aa199d9cffd3b064db95873e05246b9ec1de204d75dd775d6cc96e1846fc47895b220655832461ebcea7601f95d6037f1e2778f579cbd384b3c745062690f4a185bc25d6e2726e6594ebcda6f5e2d1f56c557132d95ceed2879c5fc10722badf9d3b4bc28ec36484a2cebb01980c237c0665b12522eb34d2124515ca10a7741514f1bc2b90685283215d7654ab3fc20c1639a40c4654e5834f7c53b4ff6602d4b86de8dc06b4385c827a7371482bd8b164b344fcfc9ec95a9ff459602671d2e6109fa5a6242c00316889e72580abccb269a66eb0414a2a2b305119111d48eaf27b4e08f2b76f846e91378563377634040150449397b35288b917d924ec4225df6bf083c957f6c3a470c95222c8766c73d9d94172127df6e0b9584f9b25a650a9d16310bdaca50dbcc14a91c21fabb1a83996a5ef14b96787b64868b66d96ec680689eac9a4633c14da8084dc22a201e7e5837572010addffc9c15ed62de7bde2f7b347910533cd29cf387cbcc0680fd91567e66bd9bd237771173d14362d101032d7f462414c87c6daa5f2e4971dbeddf1aa9a875f66d9bb8e99fa5fde06e8a18b63603599b1a7c42300624bbc6904d7cfb1f7a394bbb08b9647338e7102a514c23130e8f014178eebcde01c1f7dcf53eea7620d2cd9051b1c9de008c1895372c47c626208da0960c72fafa9d00282b5be98e801e12e928427a3ed4f4a8ca915fc245dbd528fef0565cd69a8fc1ffdb4d4687f316e85df2d565b9ab8ca0456a4d14043c7cb7880725e2a4708016263aad06d06dbae4147923d27a025c8e9527a1dd824a967e0bd9803787e25a6b00b3b095345c1a6deacfbd2b94549126e065971786f998e110323c5483cf53e4ec2063c6b725598ad4132ec1809d3b3b4402553ad257e4a49644185126615080182333622a9421e68089a0f2adf300760812921f70707e51812be042ee0c3f1c61fc69754f3f5f70c5c1d5a34f0f88e9afac89b491c3b53c5e12155bbe72ea1842f283a53fd40ad2c48a049820f7e980e63e40457d881af641b1204a2e1a57c3203c86556c0a36f6473c4c28b0af978a57a53b8289a060fcbdaa452dc42c45129cc1abd50c48b1abae84a96b275b7813355e4ff0de4e7de37d8d7043b78bb6ec853b80bbb3328e005008b162d582fa536082d9f2bf65f6a11d36ae2ae3f47a151cb19c540dd3fbcf40df16644ee3259e6235c411afed33a56754ce9c4d8e74424ddac24ba2c1248bcdaa5f5cdde8dfd13cc84e275cbf90a172c55bbd42e72fbd65bb3316ce2c55e31763f8d7d67c6269d58a0d9c5a6ec10703a3a8979907d2842c7385cd1d69e68546969951937348c8410e130a322e7cbdf89632e2e21226fbe3fb8ac1fb9f28b7c02438031cd220078bf7cad0153fb1645602b58a5a53ec67e5b6578a0f1fc09f4c2c4b7a58659956de1683e8c127b29c9dfe00ce9b2d02024347a2b31c4cb940627e03c53b873621fb3720650b1ea5970e4e9a6608d659b99173e50c0b5b133699b37fe92c3119acfeec0021d7a32b83dc8fa78740743bc06a8aa59738eec22bbfe7a41bd6347f824406e0cd07adf9c4633b72b2163cf14800e5accf999a18361e31543d951a7377b933eab907a5b9c7b04033144aaaa959b56d09881787477f6ab0a5d86cc43fad50f310b0d3f88c176e7fa3405a0e225efd39a42225b4ec72aa881854647db7071ba67628da09d5427f91c3f1be03f07680a90f002bb6171150b6eead4de23a695df1173ac57929a4190b50821bd15c67ea6d95df5eabb860456c6ccdc8d12e88d88c3d15e2d5470aba674ccea75bda585669d5fbd470c2786b472aba489aab17c3c78bc4685d05c581564fcbeaa0327b909498b18a12317cc4b9e51f051efdd83dd625b74d77a7ad6238f3649d833dd40d0efe7504ee9c3d7d318aaaf12e65fc572915c2368a2dd627d1fb9789e5d348306ea4461df2e9d9542313979f12c7ee60ff0df03bf68f66f0f2755dfb11c6e371ad9afda082863dd4119c9548cb996fdf135a8b831696c1da7ad5c0a7fb4eb506ac9c20b69336615b0b1e57f06770da3642ce6292583d311efea691ea24eb1fbb00519a59ba0f7d338afc725b0227d9749ce","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"11e2c82699f0c5f21a813151810d18ae"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>