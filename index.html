<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>IWantVeggies Pricelist</title>
        <link rel="icon" type="image/x-icon" href="images/favicon.ico">
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 1% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #009048;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #009048;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #FFFFFF;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p style="text-align:center;"><img src="images/iwantveggies.webp" alt="Logo" onerror="this.onerror=null;this.src='images/iwantveggies.png';" style="max-width:50%;"></p>
                        <p class="staticrypt-title">Wholesale Fruits Pricelist</p>
                        <p><p style="color: rgb(170, 170, 170); font-style: italic;"><small><strong>Call or WhatsApp: <a href="https://wa.me/6587680491">+65 8768 0491</a></strong></small></p>

<p style="color: rgb(170, 170, 170); font-style: italic;"><small><strong>Email: <a href="mailto:fresh@iwantveggies.com">fresh@iwantveggies.com</a></strong></small></p>

<hr />
<p>Prices are subject to change without notice due to market conditions.</p>
</p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="template_toggle_show"
                                title="template_toggle_show"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DOWNLOAD NOW" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = 
            ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        ;
            const templateError = "Invalid Password",
                templateToggleAltShow = "template_toggle_show",
                templateToggleAltHide = "template_toggle_hide",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"b8f51c58265c49d272681d572fa57466676d604bb49095a0f09489c8eb0c35d1c9424c7514bb30b4a6980fb4b898413947b8bc133ca076e0f8e0a915e21f62f976c3d4571712ce0b9cf50aca46bc4e6a187e021f937b9a3e5722c1a4247d0c17c484ea3bc8f7479c3227b4d7f52c439dc9ddcb56699ed2964de01fc328a3a6521a7283ac86bf58730cd7969442a26607a679a48c6af7d810e8c2a9503fd582be876e766498aee03a22076bb8d43f180f08ff02cede0ff8bca6b59ae1d350d502e66ad8f748a8df7d05e4f22c2a37775c34cd1c6f1b57978d6b81b35503952812bb479c3cacef0c47bb51bee7c9628b65b12cf784a85950e8ff4daff2b99b4fcc49e71919f4a25cdc055f450aca17d7dbe24b1eddd8ebba312191c5e354ae0498154234a3fe2db3c9ba5587d2dce0b882164cce605f1ec3f376bf3118f88bd37d3ce594fbb0abc114871a8b5ad83c9427834f284eed3b258cdbd6825dba45340fdee7b8ef3b401428d65876e4ca34618364e350eecfa3c071857c7e4617ab0535f177aad3451e3f9e9d819b2df6e411a26dd5aa82a1e4bb9bda33a48a0475a38c807535f43242042ef8721370ddc5e531d3a35f7fdd65b746d4814a7d2f0c28a4524a6c06e1c289eaec8e391accd1a201d594c7d47f2cb05d906feee2ba2d18818cbecd4bd042f977ed694f3418fd3f1287e2e140d7db982c5f9370bcadad0561540a13a935cfeaa8d5deaf0b3926fe52c1e80e1f4f4f987e9e752fc6437dd70ff52a23b60d9c60f7c5fae42cb49fe449870803b183c5bb951da715123818ebd87d27c4038ca129e047e0e2b6b42dc2dbfc9509d3e62f3a1d4f27b5046d77d407f2f831278a609ea773ee8ab7734cbbc469bd9ed6817ed75e03e42f97ee04ce7fdbd7d4793237a876c781b86eef8f55c65ad57ed26ca8a0ec0450b18ee09152992082c4c8adbd0f83e8b555da2e4feff3f81e5d60769380668c91e0ac75d0966130f03cbc4161a6c41ed82585e0b1300d9ad709098b640ca2a16d5e6efbfacf74e26611253c2efe38fa5289970b476cd66792540c9b7dedc12579f6eb8901fdfb8f884accde5f5aa3d5a32503c904043e0715a1cd07fb9bf9bc4520fb00da62c6366c852d8d5fc05afff9b7c2f1a045fe75f3a7f7c23c5e1437d2752d70970a2ea930d275cc467047b7628f791224a8ef64ad69601825d768d0b6dfd71917c5b9a52c6937ad0807ac04a555565f7896d738920ac29fc8a245da1a4a16a8364769d8d9a829893a03d467fc4873d6559bdb06838ed2f503ca8455d6b092682fbaa74a87a4d61193c9dfeb4a18313bd8c15633d33b72114269db532424a3b02fc9a4b60775bcdd1433cef8444241ff1787641b4f2e8036526dffb7c4d711fd8aaf0b2978a90ca874015e2621a2d778b872d9b0b54b4a4fe42343a443a8425af2e4b25046eaeb256bb6ce585c05e1381e690a11b89ad17b8a8b801d52f60285ea04cf4ef4110a3f8f52f3034860cda9b6d0593a3fa57bed737deab1803ed5ce268c4e9f7eec193232277f71fe2c2dd3a130b6ef625654592040f705a7749ed8e1104b5121d77c88c4405860915f0586023547ae0cd3b73deea19baf99cad1dda6cd441d01578e196d07b2a950c347a7570bc60113037ecf35087b2820515bb916b34271636741ca52df84b5b90d6efa3751ef6bcf271904ef682f60ba412526aef170c958cc469e9654d55b6ad3ec7d1b9a6328accae4212895240be9f11ea89ebf6ecbfd173230046d03fd5b4857fd2b9723c0d6e42bcde354f61ea710c9530c7e6c0d93dde5d8a915d5ad807c6af4dc4131bbda0114bc892cda4dc9209bf934a90807ae114617c7380d926e4a8d77d6f2acf3cba6650fed79291a824c3370ef89871a46dcad740d877aee8378f7c43855c47bf869cdc4d6815c1f9ff91aa21aeb18ad5e5f19726782a54629ac38622e018a87abd29e7180572c330e2d9dfd4f28495a2f98de7f8b91cf774b0cfa14ba78e9fdd9b179394ea47feb71cd0669903321116634996db804e27b4dcaf84fc67390d45b9445f6897be320e1e6e952e49a18d5bfa7e00c631b3720985fcfcf83ae9ebba3624755316c96103b50b9846e86fdfac88610985a615ae3c7d588a063cc3473366b8a03b2854081229c07a1e0a5f444240280965b70c4ee8326d5f24026c9dfed9030b42ad060449db0a6cdec620acc783f558d77fc7d265bcaf344c08da5d2bff1a190e6b617ea88b2dfac1940ae5ba72467543f82f0e629cb1f616475f47c0f947a23315157ffc97a0d5c4710e71eb92b26278e2fe11770fdabdaae43db1597110fe9a2523e8a746908c8ce76f0e7a073e098a5d00a0e7f6cc0d95c2b30808cad4fc3c7879c40c7ca7c8514e223e390f8e46da09a8c5c7bd61835f017edd08bef53ce8fa5fef8347469c102d9959ba47ee08aa5ead6ec698ab7e045f2e27e5be46a3336c63535bf36e4237f6d07172b50fd5e10ec9fbea4457aaeb138fbf4cb80a48cd97878bb75af57f8812917512c728134ea70b23b09dd09998dc9769cc8ea65317d6518b4bb40e85b05c8e8048467676934c27454c80cf2f212439bb8de9c421f39dcd4ad7714a23af57916aaeb2fa04c31098f0721e76829dade810a4cf98f1212eea69543932827abf146ca16648853122f93b97c99707f694cae1cf8191baad1364fdedef30a5aa2459d33bf7b301a327291952186dd2848586b852ce59dcf3b43f5c6db800e02febc28c59cf3ee8c6aee8eb39026ccde327546e6767fad9a7bf20e2e421435bb07a070deef198d202dc0aa0910c2b6b3eea117fce10c9394c4603bcb2a5998a421398cb9c58659208a242844a109868f69e00dad56bb0530f7411d57307531736eb121518c8df64f1ca8319fe2cf49cd35317b6be8fba7478e073208fd376fb4eeed8a757214b7cc2c82a274465ae7a4d87a9f3907ca4d42b98e588492b67ffbb8c050032e9293886be1e0c795bc61283d244fdf3fd0aa64c5859fdc77719f7950846532ab74998a2ec9b9a9cf9dded139a1c97efbfc3ef8030ab939cfd96ae5a7dee4354e119c11d1ef362a57d08cd3900e4dcbc309924fb0ae677779dbba009ac4731bd234ba9c2627b897465230bf15f5332b738aeefadff7224217b99087a471db7e968b848795306ace10a01a383b96199d040188db25661c759d9ca4cd4c365960ba5e63cf186c74ac311a81e42b1b0de465c02599f7e0a67e5110e442b7c3cf682be49a16516efb6f52c5366052144616727a5f0d430b9b9657bc23d863335f3a98d430db66ceadecc6e07fc30ffae4ceed035cd5017cc06757f9536cbbb1974bbf52ad8c71eac6b3486b8478a6caa91c8d74855aba010510521668aa5dd11e135edc5b0f8e781f11232256bff20b052b024ddee5e301025b8cbc9cf4da1d36f6e23b98eb0dfefee1756773c265a92643f23ef3f67d5a31a01c13f8b2c6059864cb5a113ab4d538a3d14424d385535c53de40e32a5b9fb79be8087340d64a841d0df32bfb26a34b4297398dfe85cf5611698862b42ebc72aa01dc4235af050d7d4de4bb1392ed34fa4d7e976beb04de5888d69b213ba5339514a77261d667679f29dce234286902e130dea1eb084746ed5564064acab2b304af9e44ec7fc420c08a9514e997b9b61fd5227b978d3d5e8428eaea4382ee62664a13765906baaac03ba759727e6aa4e3abd7f6f83a61ccfde1b6d8fa5906faa22e51e5a9d43d04abbfde331fe9f249de322d7d2c448e0904f8a8afa2506a50960e5d38b24806ac0b2d751e8637f4005394c6cfec96dbda02658ee1023639419c5f0002e14b3662d8991c119b763ff5f2710c6b42761cc51588d324fcf5615de4dac7304a4bd613d6cd87866d0a321bc6768926d03583f69ef1ae3898282cf1cd11cd028353758b6b9949aa8946d9aaa91f957b6ddee594d56e9aa5128600a624b1e05194d33ea51ed315779e45957373e9324f14c4e88b34099cf0f2d99d130dbca98150054624eb682ca4ae5ef5ba59f6133b8085824bf315b6693b0f6015d6d343eb888c7f5dec80c0d59365e3d400e77a44e125c434a743be8d16c9cfdfd1c30baff4f307884d0b4364697ff56e8821024998746de200e1a8992d3f87612de5475ed0df0e3db870e4471d0a5135056bc4c736c3565cf34556e0aef18bee9c4e7608d52e3074e9be21fd198f34cde92eb373148a685aaae99523066a2c86c7697e8aa966c1b378a33c0388538d6a99a1c02a338435fd15b3136c13e8ddef909761d10a2e7d056ca4cdb01d9d170177b747dbb5f215d085d1656b5fa65df62dbf3dc2a92f0fe8deca941985d46c9fa67d0928fcbf988b36c01113373a49416b1a10cdae151f9119a0408752ef0d0ccef87b460e83423bdd5f412b7facd8cc2ea5cf7906a70ef79bfabc76bbe78ddf04dd684edd49f046c69842006b62362f94df1127d33ea03864bed58827244c7319deed6e2445d757338b2c0a29e45c8354b982d99b6e468e86070752d85ebb7e63fad600a2faf6c635f9a88a98bc6193c7cb4da6382173e85a548766049c5dba597e46b4f0f575ba30f2ecc1c4288156b44244b27f624fc1e47ab6c4e587f676ae5ea19f638c8151eb749cca2a0aedd2fb36edcf5166a7e1b40777b33ba7c268edfab17f7c3c043559eb19e520186e0b53c0a50cfcb450d8e7bdb031cbdefad2ec3deed19966e20be25d882eb088a199925804a3ee87c3115d3948048b5d388cdedba1dcbf1801031d0a404cf2d94b3cc8ecb7848c43638278e891b14e36503dc11ec43d5fc9b5db545c8f6a7750183140d1be8d8a577e0bbda293c045bfd23021d075edafd332983450e7f36fe6669c0dc275b85d18b2c99ff4b7cff542b6aad674d5bc5bbeab549f1b7d4d8b0d41f262954334b2a37ca48803a2139135e7068ce4d4c3ec4e7fa0340000b6b4341a36448ed3868be0f4d77f2b66c76a49f8b4c9a893d26c2bcce9327571dbbfd8842796ccfbcb5d78904749fa38f57154bf7b17371357a6917ae85d88a1796df9f72f617c682d8779be12a190c357102e73be2ad5a5260dfce6ef743faf46bcf682b6610eae7ef0075ce4d1986497cd3e6c35baa35c438c60ee3675145c6393093039d4bf9ec6b7bbe46b1708deaababdb355c2844f953417c39087ecc5a1cd9b96458e38a361c9efc19deba62c404f64eecfbddd4d298eb12a5a862d9fbe34826be7ccd0b191b467373dd541a80367b3bb01214637f49b424d153e5f16072baa26154bd40541c2443eaa8f3fccf5220015a475716ff20e3ff0431e531b33d02c2186f56a1029e35f2cd784769069355f294161ca0f5187ff02afe6514b7dfccff0ed426391239a154ff08b3cc275e73488edd0a571157c13fd8edfe65aadce957208e25e2a10321a7f71230729701972555a8d51fee89ec2dbd99be26ac33017db87cd9b6b9854126e68f610ba10d079db456af2899e3c4fc4936465da8499c2acc62e4087d3e6e59936d094fd8eed99309fd0a9ac0b2aa2aef0e40d22ea23c7a7a3e9e7341dafb27462468946c1eaa834c6ee95cdbe22bc1e991f408515ed2ed4087b166488c059fd13a9715527020bcc1bfdd980b97f539d2790317c01c6fd0120db89aaa694b3822f88c8866b620cc032292b76f0926c911152557734c71b54573c25d080cbb3dc26580accba8dad3b23d1990ce23118145a4d89a9875e4b24cda5d817e121f582aeb443881a9fa7332caae766eabd93cf2413e59183b8f494852c5a335cd133b517cc18b64998cbe9a03fb6055165727cc8dbbe511fb54c768bd7fad3b02e85cbdd369eef9e954f5a996f4b89fb62e2fff08350a555620659873dfa68a379a5038529f6ffc8c754c533bcab968f45886f489f42efba0a1e4b41b09ed261040f7a1123dbd2dc65990d1a4e0f3f9e4449f28425fad974cd2b16afe91e464830fd86397600e1545add4617231ddcd32698e76ba953cd151cd8b4588aad4930df71d4c9794fe1bcc3030c8efba214d7f4493937aaae2038b8d27aee4a73cc3e198dd7a1cd5b4fa03cdac365ef335c963d09243dba58c3bcf35b6aa3a3c44773ca173f13557b23fcd14df687aab2742ccdb60fdb87bfab7b14b348d7cb90ff12893550f9314663b38f3a786cb0f571874189c34df516dc83facc50a3f78faabf842e01afe91c290d4c064ea2bf2eb309440c7e4b8ae2303ba64029a9b6af111a3bf55031f39b9707ac6f8497185dcff974bba06b8a79b6b2feb59e900b9b5d056a9818d19f9cac1896b0bb981cf27e5417fc5b9dfe3e0cecf8db9ba9aa76e2e48eaad8ed1c531051577f94112985264d800e14852ebde7926fcf400b2b639283c8c9e03cf507756ec80c35ffb9c5bc50124f9aea8d825732c23b31c5bed31de83ae41e2272d28516ea16b581087d3da3ccfda9764e157c6589985ea0c8a4eeadefd6a227a114d68327dd578c0b7cd72a9117157b1456b01c8873eeced008427deb30d7b197175578a034bc4ffd5229e15abed822a21ef6af7d52633d2620fdbbacfd227083ab314db2dfaed66d0d8e43b3ca318f727ce3a614c1b2a23d43243c865cc626378154d1436af4b4c3e2b0fa5e437d58a38bd8d4a5edd740f40822c7fa6cb99f8d29d48b2b7f6b278902737a24bbf3cb58e3bc06e08419c86df31a4db3d0a7f593f699f5cb9dabd115ddfbe48c7d9ba2849b849028bda1a70a26256cbb2bcd8d34eb21e85f8b82cc1bd96a2b75b53b9bf8a38002382d1cac14ec8cda2daf193a416e068ab7ec064da6f913e96177037f0a4ec1e65c4b068e1ef57b3972f4e6d8cbd6742b8c5ba2d59b6883c2d67e880b215560c8e9ab975ac3635d0bceaad98a3a275659701b00250de23a353918e8e721484c4bac77c3db7fcbd6670dec7d91ea77e23874593d540ea809a986ff1adb93addc88fe68d6bafb002402b6fc3323554f0240c10f7a7c7b70dfdf0b6cadffbd10e4a68c2d62edf44ef737b188d653424bf85a9a70abf8fd38bf811faaae3796639b00a8504fc582250de8806f881937377b48349ab41c3d15cf72003144407acfaa71a4ac8bf98fffb6a4f184ec507c1777db2dc3621c13bdf361813dae9b5301154524335eac9bf514b3f6d5f55ae429c1a7ad2d6967bb5a38dd80bde0229d22a7d99751b63e23ea9011346f3f4d11b483aefd6f8576bbb9789751333946681abc4da62860e55304d6c040e2cfbbff7953dab661868f4be4a202dedf903a3224a83a6bf48b617583a2d7e78b9746a76e913f0026ae2e22de2e2b83b8e1a7569293e6fe4b427af7288bc1f39fd886965dda78c62dd15b31d21179987bd292078cccfce28e19a010a9e1affb381d58f16b4638afed5aca0a65c6bc15f2b45e96e98b8335a86310091354198b6f0858c8eb100a043ff5abb47df5055642fa671ee2ab92e678b856dd2b06ebf00c725f7d9cc19fdbb18d9ce03c55c8a6d6c52731ba832f85c6801e781a547d9743a481d6e76f091310a2ba54116c8765bc7e5424e5a40830beb1c6f01af4f14dca39eb7ee5e304eb1e2de03a8d022d2b272fddf31850a28c5d642e05e4f6763e0441399f6e1ca18f94e7ee25c7bcb967dda33acac0a99d04ea7924297b0b0c9b32c7e95da10760d7ce9415106ca25a59d15dfec87fe1e2d076adda5086207e336c40b17ee019f645e2c1cafe2291ca3d99e78a7f1fcb60db0a7e5e4d83fcd10ba3ecf8f51a7dc6cb2e90808ce04634a993771a7de569623ffce8d8de9836041b08eb9c04ad744f567eb3b4d962b61791cabe0c421b068d597e69f22ca81586e1fc20a6e63a5ec6779690bc7fef0298584f73287fd5a4c421117647a6382189e35c1aa8d844c7b98a3e643d74dc7444d6efe623f1e2c008ac8c02c81d7b660928ed263e3887ba5b23fea26cd939a5c7c696c23be162e903e0f89ba646dcccd7879b868f509417c5ca70d0a6ab265142b0cda4b6f2b0f8cdb2de3b460657f4853a46994a639ec5436fedc2015341aa21293c70e0f1c0fb9a676310e433f06b13661f72f629891664e98dd3de75f7711d68fa46242b646a3663e5edb38d13faea37020a2935ef103b8f0fd123e31f883656a6fadedc726c3e991364fae1b25be3dd910c6fff6593abdd1e49880ade34e05c31b3e30246aa1e868b8f1343a7b6d374200cc60767c00215bda3e7b04f8b34a80e7b131f153b4479283a448a2d66127f0146ff4b43ff7402c1da0f58dfb8ce219bc506dc369081112800330822f60174bae43f3b27381cdec2ff0d6e083f99462be24acdf7de53dd420c9b1dce8f2a494b21aa13772c56e95bd318e4491d5ac576f2550d9b07ce313113d515c8f5fa173bcea58c5c45219796f30b62530fcdc6d4f96c47ea21f11d5df3c5ed4ad0623ba08d03437fc425a606e00a3d5e912f2386a38346fbfb9e59ae1c95625dafdb815a95fdf23ec5305b0d5a3ffed916d9bce82c2d3d8100c0d5a760e8239f6a34c085f72e281318e709386df5795e42db64c58690d7e969155d6517ef154e9ef56b8ddec35e9e612b4461a9d9c9db0688c4475ff149b1974ebb0cc1bd5a2bee5ca8ed9884d8b207c254f2c421a7353ef596a67f7f6bd661bc836596c91b49e54ba817b79b6a6859d02cc5703de537f7d94b0086746c1ab40194b8f9d34f3cc2e0870650bedc3543076b852aba6b766dda38770c445a7fcc24c871530ba7b081e3dba64c74fcfdf6b06ec16bc1e066ba828eeb7d8810f920ade656001c1e2a3485f3956d4330d2cf3ef62e06691304bf70fc2421548dbac91b1c1f877456fb4bb58271cd0fdddddb5ccd320b776162340d81895fb3330fb8d34b8241393d305bd38edf79f13840e8e11d17fe73eef293adef875bba5a84601f343ccccc70d2e12280075ed30339208347942bd565eb0a020d92c531e645175c95985b6d4e8a3556cdea019d39fca8296bc2938742185586cb59541c26ed52ecea34109117b32887fc7fc577b2587fa45224bed0bc49fae1d258ada28abc8ddffaf89c5b7500a43dfce26ad0236ab6b8092e42e485ab15ebea6b03a54a4714f2f285804fe871423f4c83fb2c3e97c81ddaa93b480a87110911a75b0d36686c2318769014017ded588b1ff9630a81ff15cceb0d65197092cdc8d95badba38e9d4329acb622cb5255ffc35ee4a6503b1154eb4c4275be696005b14a3b739e3e2239bf4e94e2970794eee1b0ac9936c6faa8041cae093947ba868038f272b61136043c3e33b7cf1c1f03bed1f493993b7fe3f68dfc0160060fc21114c2ea2d32dd9feb5ca423f17d335a04a1c1aa4bf0b6bcde74095424d48b7ad6ea4e278c710eebe680b0becd6004ea526921a2f703b062a0d8b10e1eda7c1a51a6e85553741489732853d78bf749220b26053a2d22b38e9ef7df6b421af1a9f250c650ef1f6885f09b6df22765cbc542c922c6adeb9e0fc63fe5b0cd4c4482d80e828b32845e1f4c1ff1bd4c74018abdd473e405a83fd44dae5a3abfc7e57f7f51e604fcf45fe08b230d292eaf111b8037c506edf3b38a5c5aa17e31fad1e85d98ab0322fe3134e2ff534a6cd4f21f80c80f5fd248350076c02274a4137bccf56e280a5041029f6ff7145f8c9ada51f1940834fcc59d585ed47a333082a5ed2f7af323c82aaa731707e266a50a33f817b36be13cf6d797c4e1b2f348a11a5389236620c07b592656510857b9503ef139981027c4a2ae23c3d2911473ac24a9669ee16bb87b7a938038f5242e648ac1694a6edbb504d561f9e27969b5e18f099a171dcda19c039a2efcdf100b7680b6cd62d81a0f2c4b80e36b507a827aaa1a502dd9c2bac865de90864bbf94dd598c1b0031cbe5202ef1f41ac851806327a1add80138de73cec1c930ab2d9d13b1ded08007b415e7287fb507e1442a18a24e8f7a910895936c49f5a0edf9832af587949cee08807476bf934cb582b0af12674a88899cbcaece8d75801e6fc47fa76c46ce42bcda9cb851c548d4d3a0e387bf33e75c92650b3cf036476a3ad7e5b1468c1cf89b7974e9ee39ae53b4b19f75dd1a574300e7f756697508a78b8278d510b6d3e346cf73af8b126152f29599d2e03ef82a293adc36337ace47afa376ba9fb82149131a40d5cdc8445a5629939ff78bf8b3ff6ee46366c7384bed58ee5879b80449e0016788d99f5d1591ca1135d76cac6a1395039edb89094c3c55f49cfa09d4bee9d66afba8c5edd14912af2784a489d05f98524f6ad556f8978a1a0518f0a3f60a97b92932ba5f4d042beca136ee6d33a49ea31b84c3adea22c1554e7ea55ba1dfe1b8f7502f27654597eb803261e3d14fa3394796d1f07611ebe5f68eefb2e8dae3d159c0d58769aa84855e3703189efdf6589925c2b51aeb264ff5475c7e87fb8395c47614cb2d600ae397306b04309ceb0211b9fea96b27e45eeb234204a84fb0f7f1ac3c8acd47317ef11c23fd4cc39a5c514ee83cbf586c8179f6b434e2ecfb1290124e360a5aa6183e5dadefb7f9eb12f32271206c786c5f2d7980c7ebea32aec5bfc8521afa11968ee091b29806746b08b030db80e4af42d82f4df0f3e911497e464529fbcda33408d39d8ba03c7db93ae83d771a4ef4e5ab8aa875c4f737d87a41b926fe7e3d7d575e7b8ed106b99ce4c620a8ffa545d10fadca5e677","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"56131b41f55d9155cffa0b1f7683fc25"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
