<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>IWantVeggies Pricelist</title>
        <link rel="icon" type="image/x-icon" href="images/favicon.ico">
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 1% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #009048;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #009048;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #FFFFFF;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p style="text-align:center;"><img src="images/iwantveggies.webp" alt="Logo" onerror="this.onerror=null;this.src='images/iwantveggies.png';" style="max-width:50%;"></p>
                        <p class="staticrypt-title">Wholesale Fruits Pricelist</p>
                        <p><p style="color: rgb(170, 170, 170); font-style: italic;"><small><strong>Call or WhatsApp: <a href="https://wa.me/6587680491">+65 8768 0491</a></strong></small></p>

<p style="color: rgb(170, 170, 170); font-style: italic;"><small><strong>Email: <a href="mailto:fresh@iwantveggies.com">fresh@iwantveggies.com</a></strong></small></p>

<hr />
<p>Prices are subject to change without notice due to market conditions.</p>
</p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="template_toggle_show"
                                title="template_toggle_show"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="LOGIN" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = 
            ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        ;
            const templateError = "Invalid Password",
                templateToggleAltShow = "template_toggle_show",
                templateToggleAltHide = "template_toggle_hide",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"7ebfab21fe6194d91a8cc3347eef817c9192ab3e74f95a6175d8b23a6633140df3c41bfcbed3c01200a4e4b761a38ea983fa98db6e9bc4b214dc0e354dd13e6eda4d403707015c7188c2585d99b1c477e141fcc6ede2be041be901b4d58e330bfd17c3168922c660b59d308ce5dcbbafd4d38ce85e6ac6ffd2804e8ff8674800a427ade3e0620bbda225884271b4d6f8478f4c03b8d922003631bfd038485396c4dcfdb4715085cec0cf4ba15fcfc781afbcacf191c8debc7cdd5e5c49aa9388c406c38365a1d554988dd821a29c697885ff61e9e8a3021975b68202b45836b33b96fe2a9fce9707057796b7488a41f2d60399db957d8c73a562e25d72d24abd7acf1eac8126d4aca06b6c46669c21bfbec4fc8a25f5f94b85ba28df1a71da1b1cc9f69f336ad0014674fda0147349b77f99ed4f6804dc8361c0281c2cdc4cca8392f29d7e534dc9b2972bb510773396d9879caf622d972283e466d1004ac275c3fb3869d34b431b335bc0bbf25e673df205fad3a7f27dcc91fc97a4ee26f50bb6c843b269776f50359cd148b3eda9cb7e7b598c693bef8aba4fdbcd9c5ca5dd860a317b704c9e83bd15b79d6fd1e242f59a90fb187d37c9869840859b46c5ee8342d27234af280281bed055f525568c27c09310904e17d49a9476316a246f0c27c947dfcd645f408d08cbe538694d5707ef7f568512e34204cc4bcd03eff8fbe43133c44daeac69f967adb52b74fb41589e92ecf50eef0bcf58e34126b0fb6b93ac54f741e7650fbeff9baf9ef552e458e133826314cbb03b4715e155edb6f0c0b492c958a516e47ccc89508790a975846ba17a4d076a5fa5d9dc156101353d91b62b2f97ab1c8cbcf17aa34b63819ccbab8bd7efc88318bc63a51712ef4b597ddb7a651b3a443f4fe8374ce967c0cb47e03ecdbe1bffdb57347e33a92b8d0bdae20cb7a5ea4d9639cf252113dade872435fc8a0ee5a6a5db3d0d7098eb785fcfc959bdbbbb3164a1eae3f09b6946bdd881e0dfec7f4165e42e4ade19a39cf5f22028b45fe619da7d8caf81f463fb69152bd8d6c1f9df5d30c09817b131cf64bd34d3d1dcc59be991635da0490e9c64395698d8dc0c13102b011e0c6e45755969a03f827ab449c8074f42c3681a9b450a3471aba9b3dc127a93d5fc9358e271c4de4fbb76d6336531830b686d2f1f4d84d65583a9996bf770665dd2106dfceb927ba9af3a7dd0dfe2979aba0b78c335ff54ca5d49211a155b769ef0529eca364753cee2d849178c854e48615370b99b2cf826c0c74a8ad8d17f8145d0e8b4cefde862d5fcb2d97d7aa44da1b9596dc30794b2af307cfb5795b257e1ffe108f7ad1b2f31b69a107b43bfc477b6d9824fe3d525b5fc974ddb70c7d69c413437875ccd24762e1f677548c5484ea2be5a0cc33b25ebb7174709ecb54d9b0f039288274bec5d6df8d3260263dfe9be6be1ee96c732cc26247e8ae76d327e940f88acb6bf5adf07bdee23286fce5b9730c875e5142c6781f254b710a9cdb05956b92fc01de60bffd327cee194c9610cc93eba6a1f5f3fb4e23c18f7b584b0fe79cfaee10123a715b21b89faaa79e5e61d7d7b0e02a5bf77e867ef588bc512dac3eecf9503ade68cd3ad86da0af1a47e1ec30f31d06f06841a6d5f21f812b32d2504a5d58f67b0002fb0d540e31e56b86a797d986083a13ffb224eb8d89adc2bcf6798a6d1a43e3f10bb6b7f13589ad636a2ed68d5c1e23699214eb4c7ca2ccae246bca8158ff307535c46f30358f1cc2c0b0acd1abc780424bc40f54f00bfc56921603963a41ab0ec87f2d3d40f7487e98205fd4bdd5a6b97bb027903e6954d7add012bffe7584735e99d67635a76f339c6d02644a9e4ea368283a214fe96fc36f2e28c04a1b9cea2bd5b54d27b7a4acd2d4d5894b270090e632fce6e96d4915ec0d93104fca9759b53f04b5eacdc642531fd375cc5db5df71339f7ea7c73e19ffaaeb64108b4d4dff9d906c42279690277ac8369ce73794690326f518406e1294d9c8f768cdffd021fd1659a5cb9956cb80847601fafc20b413c526fe0e044f1645d0d0c617721b3829aa041d9cba7feb45bb71d720a62010a92801ecb90e1f072862bf1dc6cdce027df27fc38f610e5c2acf241a7aa900b0cb6181560ae1e64557062979e70f2af6fedab91aaa509f85b776c42c29d17efff7e3f342f70848b9d1216d2bf8bd35bf68399c9d8c6d077647f9ca49c83d712dbe09500fd34d1a62ae6d7d3bc07dae4497c2154523a570c3bdda8016564f7bd2f8e53f31d7d2a9390bf877fdf057b7925efa9b629173e160d8615ae06e3c1545a2575da81467663519bfa8d732588e20b8c3153a81ed433aa4c5d91a171c057e3334b0d8417edc8c9ec2bedb268da2ab537e40769565ac74ead143c71a42b099ecde2d3a1e9306541586f26ba9402320891d513df5efe3ecbaf3fb91313dfa331c530cdcf881d40247ba0c08aedaa74626f4fa3e87ab24bb9a92dfbaa855960e9b15079f282c6241cd1fa205bc1d9daf67a9397f7d1a9fc0e3ab116400c86e1de57abd5ea32a550fb3f9b42e3b0cd4887f660b676c23678e3821adef06ada2acf3f9652b478b001e7f10bc79ec1ecf4986ecf0da29b287110374af17f02ccd85a17fae01d1753987efb70af565281ac5208b06c3854e413a2170a1a4596c7b78d735c353681366bbd44c96bf83b912bb599df1203284337363f424ceb6be99a399a0ad61ea6e62a7f0f771c3c63c871e8be904bf0a67f7a52de021caa9add64a1580d375038911cb0a69ef2a0cd5e5c33a0bbf2d43c1758afc5dc86bfb094f58ff7749488b296120745240c6c42e813bb4f75c0f27095f2c9e0ed30264022849d46cfd5a9824c4d4d2804b301bfd85daddd9261e0a10ce59dee53cf2f29d544fea6277cb593e7d7d3912107e0056d6cfca889f7b83425ee0fbc68e31752fe20bc256a1a3ba5e276f10f9b043fcc798f8e2c7d36bfd6b03e33b103adea9fe76a53130d8286307252eeef491ad316bbac41b9e36ff19237929ca35473796e6a9ae522dd58075051386c87b817a3e0f4eb119109cc2237a1d8c407eac20dd63a8673a0c308a6720786b153ec25f5f923bf1c02056cfaf16194e20aa9858ae097a056be7345a4d594bab33822845339f95c12903549dc002f281548cc90bdcc080ddfba2594bd3ed2fb812468f570039fbfd60bc3d29c5fe6b53ec871bff5678c93f899d83373275a5c71a5e4c79c4e9ea3fd7dd0195a7ceb0efd9354d6d9442eb8c95b5c794e0f6504db0d4c4cf5c23a832635002cddfee5fa805a8933af326c75855254d27290c167c386f1c32bcbabb52441e3cad685791c3ca1af7c41e3caf6c006eb8803b21e3de819001f54700fc87e8044df3c50bdd229ff887b0b07f17479ccc5e3be2f8d7e12502ee8027a6073a11c8f6c02eb47efdb37e9b073fbe0c652a63c930d759908aad1fb4ae3337f594dd6c36c167b0c8051d50e1b72520093dd468d761ce1b33db2a6f50f4c0be3b85dc6287510320db570a8fd5e9f86048ef33e6839cdf1dcb2f1eb833da9eb4e6c920c986b7904873ce986bbcb65c84a37e2c2244c51ca11ce25000a2d0a2810c22dc89ec1bd5450417e4d702247dcf5177eba135abde24746f51cf29cf7761318349ace7285f6bb48d51517091a74a16722bbe066bcc8f612dc6267f98fcdcf4cfe66edd7bc0ba6f15af469786d45cd2e43f18933d22e835b03c65b0c76d4556802019327633ba0c0794fe4d840effb2583b68dd7e82a67ca40e066401126f69188e5c989b3dd01a60fd39f9c5e6209e282a875f3246962933024a5993102e863bd9a67ad5f1c715846d9d57013696da92ddac62bc22d3589c94e5420272feba6c70efb2dd4dc5e1d666e581ad11f34fafa83a0fe3892309e938680bc98bed85237951d467bcbba6965d07905e2ea2242ce131ee04c04726b35175c52c582453c5134722b25db7af33dfc7cbc90cdb17e8a3fe9deae2b3f7ce19ee2e5a409bbb8a6c6ed50ff85e0bc926e4e62ecb289048a91bb17e7ac9f9be5317a688a2c29bd77a8712b811010b33882d897908edd44d8e5ebbfb3a083df7b34fb308515de9f54c0a5a1921f2870aa2a4165dd940c9f698de36d205855536d96df20d6d4220a15a280af872b5c357f6a9c24c790bf73b50e0ea56c585fd763bc8710f9a1cdfc825a4a1e094f5c14b289c1cdf17ea811768709a32c7b8039a376d2d07e3eae33cefe6158e0091d8e7c9ea2d2bbc98ff95257769f3725fa529b4a7f73a1fe943afab491c4522c03c04892179ca13052d3146e400ac440c5f85ef019bac6e25009e0a7e792cc4f425fd2962ac18958f7f4ff7b7c7e6237851d5994a99988737fafcee9214e57f2059a2c77e4d2b6dd460342d1251dcd4f9e0823f755f87473190c4e4cd640a09e7e55be09d316c648960f48f4b885eccf6d7441fdc07b233ee1e5c64ecd18bf64d646d0ec921bb856c1d0369bd44f8c9750d558ebbbdec08340534b8a186aebc5acf4f09eccce2b22629771ab8877fd23160e9312d9584ba15e4b7844fd47bb49ce2f5ccb64e6b29433c07e5b16a89b79a4cb82a9e35b5150cebe6007177821ad9acf22e061595fd692b0f0344db6e0503c7a5efc099f261d4659e89661f22ffa2a8d1f9622c77841a741030986721fa2e044bd85c354dba75da7bd4f689d6648463424ada8b54ea616a85cbb86f5ff0888e7a336a3f6e53d3453e00b8eda6b0b24a8a462a603a45201635c8a0b13b258719cf48978ab3805b57f8dd6209eea50eb3deda0e1fcc101d6918e70123808d6f22f5582a65d6e90c9c81e1e49e2a2d821527a27f06683b7759e730e2ee6ddc2f5ab22fbe1e31096b97906258276b353afae7a0c87fad2c1337cfd7f61294b3b6ae47c2e4f4b0fa7504dcaaf1e362edbc5ee3bf6f7388364b5d15d1c91c36475dc5c980104d022424a83e984b176249b56649cf1726cb7a37824fecb6832882de28a0960a91a1fb7409dc92c0f44c9722ffe3e6bf0a41872d7a06a2e04c8462b455589d914f0ec0d6dfa2584efb040e7537f6fca8f67bfe60fbcb4f975196f26b0685b2333547040396aa141957701b1f3f0367103649073f8546b5f5081bef9a93099e762e35959c954818e3f93360a7d86cb579cb92e6249b37a0b11b0f32e0a00fb960f8c5f2fd20ada7a86adfb5d9606201268f92b1240e8e76afaf57e27ee7bdbf9db393674af0355162c21ddd70573f2525cafb946e06f1e476a04a967d7f8f59e98d3ee4158630c13939f0205047a698b813927173b6d633f72049c13434df4bcb4bce9b3dc6c4c36e08c2d4fbee23a37d522df823ca934f422f71613b42ef4bb40f87b1b9c49a3c56bdfcfb95a3989d4afd2d25207382063a08c3f331875a32db919ef3e987c602b5ed68788a22f3b00ef15879871529f1d59a5143769b6653bad66e4d2fe9a486f5070919c0221d8940de6a71510d053f143ada45d855ff2fcc77ef36c2a070499124df87faef102f67bf726c9ef46f5ae57fd49ed999d5fc8790cca26df69e3a3f3f0f115d873128771bd4e04ae5c1668a4acf00cd4cfc2edbb804da778784527a2a9852bdd9bddcb33f704c6c14d10aecfad4f3a3bb4a7f1557ead2359004527dd4816fa53611d9999dd51f064d7105cf50765b9a45a1bbefcc3f5039f66c62e53a27368dc3c1ddc3d9eea7b55f0def8df8ae45338fced576ba89724e347703b02208a5c604383e708e6cc0453409b0eb1f7807d3c189af63ea659a95107a6be7d1b413e69d0cd799515d974be6318c5ab118d7cfd414913d5d6c61a9b1059627aa543d532613d481fa4f8d062150375eb4310284ec30c6870755cec0d1b891c6d80d19ca72664d4e5c120ca9ed463672d5bd2edd8fb7cf0f7b4c100af6a634b5fc287fa1baffcd33ffcf53af4b4e60270ef18bf11e3255efc3006a9c3219bf67a274eebaed98e32de5abd2b5eaad44bd337a78b2b0b35494f5a9255a6c8f7bc069447bd787774760302cbfd2366c3888429ed05a22d61ca4013e74afdbc8ba2b58eeefd9a19f762a3159ebe64ec3d70414892bbe390b429a5d75323d5798b56dce8a688c00a9b6b917e1129b95abf0f1715cca5c68a7b29e41461888a9148c880392e7db6b4ea949d59ad01e77590296b03f1c12bb957dec9d6dd52010c8c56b5eefdc8e6482f337ac92a58f1dd36c811e6d7e72a4be5dfff2d39e96aad43cc740a65b48d1e3151721f14d5f1479175c5b43fe2769fde56ed4ca7aca916d72c38a914f61304101a00ccfc0e9c1ef332c62845704cceef84ad06cd69684bdcc644ac07445b9f1a2796062bf6e91cd9265fbe42e15e194444cfd73b1c3500e8a35e441b321086179be4dcf0a89df5e4d5b57ed5c96618785812b88a2154badddcccbe17db3686ed5cce9e0c3d09b8dc7e14e7a3e5d2b920c255d526a85d7608f40f7091b4ff0b176dd24f8a1380cee13c225823154f112012d0c1cbb32f0c7619e48f75223ee2857ed26b44d5ba4cc6e6fb898dde2cb2bb7772f10473abf097beb5039cebfbabc32e283d1e3834862c4c7733d121bc87c60d04072a17be869728585e440cbf0d7969275c4eaa0107641b87e15dc0f9080747f465fc90c19226aac940236021d50fba572b37d8ce770f9dd5c0d56d7313e2c0d920550efbee26bf0e4a8d399cb351b66978fca3ec4168f27218f75e90054f7ccad5ca9a689cc7b6bf87d922e9c66170b1816c127d59e25ae1646a879745574e7ca9a7ff7cffb4e3540647a74f6467d12804ae44a2d2f25a467d7081f8819ebfaad7485175650d1d9de89c21bccfe7205250c35dcc77f6d4cb4890fabfb16815768dccdd9f2f09781edfa999b62f43157ec182e121f2c067d133a4632386bbd127ecdc0e4345cb5ed3459a6b19d5e9c9269821713e8b83f7808fda8b88efa97b400e9ac0d3c92835771202e613b9e501cda47cecb1702a66c68c7ce0ca411a0b42e9e31a8254e58f84ea26fb519e40e616d07f4c49d740fa706c6edfe0e45c6cf821622546209dc8dbce810e031a8ce36c8f7b78661f5c5e0fc326563ce501d4a15ca83ad3adb286f4848a441ee42b601e92f0ada51ce894a93df0006d5dbdf437cf469e82382644319bd222ad33512f71cd8d6f7dbdd391b507dc51d6397af854735c24f08fb6902b94c16f44d0e9cfe7fb98005b9b326a2255949adad457ec604a9bb8b6e1351dbae67e5c65007daa401c95a468ea4b8bb4a45eb923b859b5bc22b23b66c5c3c6b843265a00750b214155d6f18c7e207ab8143960c2cedec464aed3cab42fa7a804f79da19e19507fc51905aa1cdb6778a808e85f408a72a1a9b1939abdfdceaebe22e3b374f6cf8e72aa2f504d78958651fbba15cddcb77732eea244bfd5549eedc6c6d67c3e3317151346c026c680dc89d69320f9ff7e208e8357b62e70e4c8839602b5142fe470e9315f7bb197e841543287980fe9acf0265135a136e608a5824ac82cb494b1ace4bcefba0396438a11526fefb554487dce9b6e07336c50c2eb8e8ab10692594236668e2a1a2f53ff5c28efd6f228dcec7c36669ae3dc47fd1dbaa5c2e9a36517f4acbe11b71aa6c96c907d6dfd77e11b3c7cf028a8dbc23a63946ae54d095eb83ebab04e36ba1f4ed6c6a6e77e5599ea7b1b42574f9905f2d07a5869e15af40bfc658dbda40824316801d5d33ae606fb6d95c5a4ff3f30184d09353e957293b1104cc47609814e6701aa7693fc3bccb012c202b5f1b63c4eb1ccdc7184a0da2c6aac4483b51118dc33f62bfaf4a642eb4f48bf66922226db5a04618869dd6fa55337860d0a5d553265cfb33000af1719cc9e9945028be2a60c56e4f161bee81837226837b0f15064c4eaf363a92abe6c8ca6c41364d051bc54b5a36a9d180c585d333a7c1fc19dbe67884176fbc396e26558f65a9031b2ff628f743a7c93f2887e321fb816aad73438df5c5cedf6b37fda9de1e8f07aee4a9ce9e70dc4ce2cfbd0f90600351bcb2cab0dd467cbd752b2f2a50b36eb567f39fd57fc2b307b23b7421d61c55f5cab7bea27fbe4a2303e4df0a325874a7d48e3fae9815ac78e7e63d84e72fa92dff08ab92f27209ca85a543e79174c4a042ecbf1e2fe2d42cf408fc4c757af7cc02170556d0fb6e1bc0d78c2d1cdf6e296bea6856733fd14b299f4679e619443e1909a60ec7b26d71a18c2e95a16eb52ada999a8e40927bad16765704e3411aaf003be19b8cf34d0ae7a99069da0148632e598af9d677f1e8dd54c86623d2c28b9b5cbcca9a7d984052cef908f43226aa6ee8c316b024b39d53b9b4a7ed842fecebdf0933bfbddbeb5bca53a2737deff9497d499177ac0458c4134e343311ee487a3f6770eff166a4d8fab1822c2434d49c316b83a8578509dd034e60843586d9f646fdc145566457ea0ee3c3e8f7d8a37741681716ead9862ca59120cd263a7bf89918a2dae34b6dd0b191595a2db7799a8a580010e26c6c173d6f1f14e5b5ae15c655bde5a8bd4e970e56b641b4450af6c20aa67a185457a8c11c2a7f561d2aa2051aabc1af3857d7358499694340dbd4aedb8463c95f0a60edb72cdee34175f659778ec8a0be772fdd56602ded0e789d85feb278106bbc6ea4c9c4aeb3e83980e824abaf65ec96600db0bd91be91a7567d02b9a0313770ec03f76cf5c53c761f1965597954bcaf5e918c5b20570705a724d5155726692e50f50f6eea600b64e9cd926eb097a1c07535484fe7e0fbb6084c5a7a08de68294868b799743f40c8ace0da9eee85762bbb32eb3a19f0c0f26875a14557db4bd3d4f81196cb221f7ff8daeb53a5a822877e6b15863faaaa0f5a834b5cef15ad400ec5149a5eeea7a98059b616a506122f5b50c7ef06ed478336dddd4db463632271f9f07824915499d1e4d5b03f6dcfc6f78a8d9dc257a36815b891e752d4e70368f8dcc5ebf78a80e4c97bc4c091a8bf2c2839fbb857c110b5a036aae77a6f6dc664d01f1553bf98666021ae7b63a75d60781a810d61a76ff04a368edc882189faf946165bf71f01a1aefd174a4ee1416730091c5eb1b68c23371180f82ce166ec69cfbddaef0c6d2f21e3bee68c84e66a4af5ab5a66badd8a48711a9c6ffd591b8fcdcd61b8bc7146574002444a8ec270da265ff01ec94ae29307095d91c8ce59b361cebe865e54d329cc4af725e77d687d3b6bdf1d3038e7eaff92fefc7d7b87237c3e5a9c70b9dfecd10c6233b15b8b4034c388ee3c4db757e2ded093accc74d08ba9786f2484b79ba5e288ea765a1f8bb86b20c2b6a5e6582be152c227ab73f944a0e560f8a7f9ce179a6fd5c5eb0729ea7a3aed21402243af4ce8495d26f5864a943be7f303e024f78fa412c36cf883423997cbc8620a49904b5eace255d38e610e8e42f40e994c91577881d3573e5e385eea310b0e99b74d16c3e38be82d94b3fcf855b9ad77397f8c8955d9b0481009fcb7c6d836174fe76283a53a98d3ed1491c9ae75b2d264d8753b2d6dfd6aa3f3c4f0cc2cf4cb5310d1f3a90daa30772197df184ff4612a90b839590e0f0ec718bad8ff13da079839ad84b0ff0f76f9a90a8ad6a62c0bee7e13bcf0f986915b31e5d61dc2d36a34b910a6d2dedf73e4b472c3b6f4cc7c7d912e1fde8891b7b4a9a4c930eddc31194c9236c7d94c4a67af663288b4ffc195b88a48dc3567edc5e02ba44780774afb29880d8d3cbb4f97f42a0f8dc95a79a7b16482f40990a5ee0e921c7538830b4d4c56da35325fb9ac4def935187aa73d29e4282785f4b575fa2c4124421b014ed54383e6977d3c1a73b98bff6ea3bf6ffa6a6127b762ab70bf6c59545f02b66b9913823e1ed9a8db290d1bff5ae8fa5cc2d0ff285c86a9b21921de75ddb63ef7e232a772f75b065caa4be022da8e7366bbbd712209c3520a0970077bacba3c9df11f23505480a4af56cdb3941ca4244adf824cc6cb691bcbf588139b458cb16894e2ae940f402b7845ba7621788f003d3b2507b3fa4548399686f17251e4c5863cbbf3b375b44d13193bc9ef3192f8434bb49bdf26db86b9ff7eee383f08336c87be7af82a67a3328f51815ae0c8be5e001053dbb2060ae438c925dc95b1caf012cd951b654d96725b7feb7c624993026a9e1adba1678254d1a17ff99abda26d9bafd5e68582ae48004846e54a146ab2ed0b553563f4e0ceba1e57593cfe0326494c69c8ee5d836a3d2842727c2537e451a311f92693c35373d72256ad2e02d068268de22a0395cbc3d864e0aebb5e645d183c5d41a7b95f4ad4c37b3f8412f1dacc14b28cda269354011383adfd4d20ca7068328eaebc9231f3a11fd2ff8f23a065f9a83008961f624e24cc18f55138685de5ffc64b2603f6ebc1e3dc487ef8dd389b444c248b28ca5c0cd3718f39bb9a0984c1e8adf59b620ab71390a093b8ed0bddbd14e5a216c03b953a529d48ee366daf976d32839b204efada47f2eb2946720135c4e80fcf9ae15bd56658cb22fd72d686f54eae87c78a4c97b4bc78a4340fc56c809b247dc477f181efd34a2670d3a6edccd32663225b8f3695a291e56c6dc573ce2670bacdbc30dd71777e766509ef1de0b7bba32b2df942e8b35f332be32e193f10bc9a045f6a9e5f76d5120b555ad17bf80457e64f12b60cebcbf1a00d514318edaebff076e8c8a48a34d73b382abff73b58c277319ddf4c514084e20d70a0adff3c480cce962e6b43bfd6d10cee8f728bf8f57a378e688efd9eb061dbb7aed48ef0659c1fdc5bdbe9377922494eea66f2f359d27bd4cc6c07031ce7c5b409e8210449f8610896cc3d8e2102ae7974f3d8823edf992d57479ca71c38d5816570a47403bbce58b955b0f8426d5b811560c0da4941dbcc0dc6c6156f25027cfc2470312f74021e1fbcf8f83971dfe73953f98c735cdafd1cc3170b230544bfa6e699bc7af36c3443aa0cba2699a5a06941dc04266b471b6bb4f8e51af8935dc9d1303714f94ce01a1fddf7d6bac2499dd5daf208d7f7f1ca3b1a67623d883debcd78a2d1b0ffe77330fd2c80d6338fe742041935dceba0c06b866a29ac569bc838af7f524eb48088b03f5345d84b67c56b109e9516cb7f914fe0daccb696118839dbf69a965c4ebf2d0dd1c0551c58c10a1d76f2f232f1068815e1e49fec211801758b3fe5ba1d8cd8843fd5f522bee4d84fe555d0a71dfb894c0d9026479de577dc72d373d0b4564cab9f0deea3667f808a7199e41eaeedce80b21da8510126ae634f83f60f42d9ba46d33ca383fec66a84b920d03639caa2065e8bc9af1f1acc33f4f1864a53058925825e3e187161f8abbebfdf14d7fdbd6d7a720d58367c9c198bde4065cc7433867d7385c2c94c03a4ccfb7234574549c01beb1e37f6940b0a6573198cc64bf46ab8cccfbe536b8dcc4ac9b5ee0e771f3f98b0083978b044edc3879ac7433e54cf1bad618ff7edf4ebc825aca64f23c006f8a9f40e2030b77ddaa196551da53c814d43904c1e5f5fc9672d037866bc38b0d338129f0cefec8a21238c66b0dd605bd712dd3f38deb38c7108b7eb822b02ab0ddcf8cbf87568bbe9a3d47cc3324a653c51b1c0ac7f2de61fa26e395ada51cb60f42641192bf0f108a8c7384af86d508550fd4cbd25e9082c27d914a0ce429fe83fbf68e22dd1710f120aec018f0aab2f5ced23b498c014f500eacbc7cc694c95f9e7a02f52f052d27c819665e3ab906ef449be5298d3fec16ed0d79183d5cdae607ffba6b01ecb9ca1dfa9992e963d28ed7d3b33c223816201f46d94700ec8f85cf7d86aa21e444de129e232bc3515c07914ce24d4dd76ca887d68b2b0fd30a7bdf059e8e891c787fa1a22231031dc1eef5f219afcb07e7c6e2f83a7f7862cc76e70905f98e91057eebaf1ea758bdd9e361e935d2d18f6a8559e93e0f61f8333e284caf7365a58aecdc81cfa6f13cb5d245316786d3142e84380c81380322372d86f4c32a7b16ef190aa","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"11e2c82699f0c5f21a813151810d18ae"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>