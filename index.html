<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>IWantVeggies Pricelist</title>
        <link rel="icon" type="image/x-icon" href="images/favicon.ico">
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 1% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #009048;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #009048;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #FFFFFF;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p style="text-align:center;"><img src="images/iwantveggies.webp" alt="Logo" onerror="this.onerror=null;this.src='images/iwantveggies.png';" style="max-width:50%;"></p>
                        <p class="staticrypt-title">Wholesale Fruits Pricelist</p>
                        <p><p style="color: rgb(170, 170, 170); font-style: italic;"><small><strong>Call or WhatsApp: <a href="https://wa.me/6587680491">+65 8768 0491</a></strong></small></p>

<p style="color: rgb(170, 170, 170); font-style: italic;"><small><strong>Email: <a href="mailto:fresh@iwantveggies.com">fresh@iwantveggies.com</a></strong></small></p>

<hr />
<p>Prices are subject to change without notice due to market conditions.</p>
</p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="template_toggle_show"
                                title="template_toggle_show"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="LOGIN" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = 
            ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        ;
            const templateError = "Invalid Password",
                templateToggleAltShow = "template_toggle_show",
                templateToggleAltHide = "template_toggle_hide",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"ffcdb299608deb9edd9dd7334c5e93d4ee2bc578be03389544d4efb9f8976fe932030e2fc809f12257576a937254f013c5a26da99a73c23207c8fb2eed9645697a732cbe2a594f11cb06be38db4b736ceb7bc53281ed4960606be7701bb43774bf612872c08e0a269902df66ae775dd664fbee86892ac02885757d1b22b02059280880c6ea8e95660d2c7501ed7c153ec214e5fff7f60c13df5fb4469c7acb9dd84460bc4b8addcea9bae7456c83cdebefcf79279ab37d9eab765476300d04a2f950684bafb03efc0b06673da1eac5bc65aa300f585d7a8f460d4853bd8420a7ea6906331fef654298d4ec0a51cb832ab45ba047c81845f4632bf699145a204d3dfa6fcc5823ff0cd1a8aa26218374c83d7d153d86485e33f27021f899e52616ff765a2c3e63606813699e7f236913b8061fed6624a4bebcd9f60ba8d7aa904a535b44c3ab2c522bda5bc2cd98b2ff4772264e913536b430024b8ce21a63718ba7ea456574e42c658a2c87c8f32e8e2cb83933660ad10c68fe5076e5a3b11ca31d25d90cff06b597d08bf17149b1dba05b1b2914d22c20d2231081031a500bdd3e5101a51ad5e818315c80774482c4295db66d9d2855202044452c595517103eb16a7babe105894b9391360fd7ef3417276ca4fc89efd496a56122c403f4479639e556dc3c7569faf2d533629d3cdd7d54a21250cbbf97ce55ff8e4b7faa8ec1de711d3dbc0bbe03941f524f86c6c03875bd9f0e60e6a6baf2b3a66d484f4accaa3da0390059fbcfef365ae101c5a34f73ac1b37c7c7312786fb2c908c86b2fc617cd6c44e2abbff96d14131b4bb01aaaa3b8690c4a2c729dc0b17adf1315bfdec589c18b3b5974fd8f71eaff918a23122344838e82f6574de7c18648435a489640ca14ac32c3b20f4302fc6a3d623f63f54ff8e683a40e66fe45dc74e994c5f89bfe069858a7c05b434779ae52b02ae264a2f594ffad7d400c0b28cf865c6d2540eb9a0b6e0e490ffa8c5fb4faa6c7d4673edbca84926d46571872db2bcdf99c59b2bdf66ac41a9f5b774710c4db21dc5593d0cd25934a4b228b5b08994af070a0627ab5d9e182fb7d0893be84ed110c369b9a67c642cfa8cd71d435a72ad6367bd7f5223b2f9ab2ffdee242a29b13de98aef1b50334cb4b0ada64d3751fe46022a505abd49974f0445118a760bbf58dbf4de26004d48d46872c9428ebc7be11a7e2cd2c9dcc23b35ec4b8b2e1e3179527160a71309ff33498998d314c1e59c332290b8059a9ec502659466613bd9031172731cd9d42ad9f240f25a18b8accf123883723e96f72578fd426e4e808111473610a554285fd394a7760e17cf0e10c36904d3e462ceabfbc5ec48cac68402e352a4d720e780851cb14aa3a62c3c2bc4aab902f6de34f090c85eaec2295723aa30429843c4a5c2d15520b116cdebb080eb2acb7d05a26edb48526b4a0aa573822150454a7e06bd5e36b894b03d7d87d376809f6cbce11a857cc2833d8e8089f30b5a3ba92793bf4c062106b68c4f8232c6392654e0c1c447e027cc9dec53e0ed51c2fcaa6921b330534a80c863dc2f89105bf5a2fe0a68a175c1daf5d1c7138072444f821f5ffeae242480652f4b9e7ba5e1ab91cbb569c5e8bf73f757d7e3bb4c082fd04905d9256f4b26e6c13ba371b0e457070b05758a8c4262b8ec0afe9bf795e7b9ac6e34a18d3ef8ff750220b7405919c0ee93ac98a63ada9be99473090d36a363f84e13b8cd023b8b094d897cb92b815b53651d7200e3653b74548f833354c499c60c9fad41ae9e5d00dfcbf42152ed834775e598821979f331175a8ef947d9fdcdfb9e632feb37620031104672d5db82cb8cdd0f911012bca7e8ab2025d71a4c5592dc32177d73c9763b68adb9c4c1de86234358110cbc4ddf14f7dff8b83d0edaff476d93374582398344191c341f7dad8d573715c9145e918abc5d1ba9618577e4190841496d51b685db4d384ef389bea03ad1b0118fe81d97a4b2368955936b102e9aedfb5bde23f37a6796eb5d8e117bd2d1e5976c71c3fb1b2b1e679feba8a8d577f17280b14527d9c0d0ea793b3d71261b1fcbbebfbc30835c219d89fba7c79b5b5995ba7b07e0f6f3268b2bb6e174e03d7ad76def133020403f3f7ebf2f021cb077d664dd151c40e07a3677a09fd83bb007a7933baa62ccabee3fab66e6faccca961c63560898dd58a680b297812d3356691d9b9bffacab078bef0efd687b9f2f3ab82b771b1bf15204f2fe54549f72725789a6c032d572a5da9214f478fb2c7eb0249568d9fae985e484fc762ba74330913176b77b2755c0b8437dfc24771c056e1c51fa688e2f9b46b870e466b5500c0da60606233709b42fd9f56e9927b9fc2b7da99918e5cec4e92c00e0be1920566c6d33eb91b0687a924fee4c8354884086e7e9035bc9aab542f511121c89b845aa56e197d2f2d99e3442098f42a75ad656dba351c145dc0133a1015ada306e733e8d53463015b56485461db0b2af2cad4b7d3d03c90f4970a0fe97f36e6b0d8019d6d69ede00871a7e91560df76d88af8549b24b3e716b283c79a667d98e4275099acc41dd2213d2459922b266b9d4d114d42d0b66e299bb4676dc601a22140a1b2e515dbbff5aaf0ab6f2ed8e085540ca959c78005542b6582e24e67bdbee57482f6a33e572538e0b2fb3cd4931a961980a20bc22a3cc977d4bb31315d8b092d553f2b9a10ae0404ff2c64a770d8b1a88d5686e9919d2208491de8a6619ada70f3040dd851ebbb90fa06cdc5c1d3629d228cebd7d17b794ac6434f27763c254a251d6356c5c5649bb0174badcfd011a6a00769bc5a15bc17d09c26ed95d33ae3f99d5abce489c729fd6ee45c30881345b0ab4aea5a3a2def15b5e14154a4612b1aaa98d27a859d8fba9c0bc4877c59c453f3af386eb65044680a22dc6b7c72a301a92eec543565f518b0c35f6f5e0c0cf00b8d4df94db7a14c59c7a93521046ec2993956ce269683ef69e689b63cd505a51bdae221bd0dae563bb41c814205fb8e13605b178cd9cf0ef8462b30dde46e13d0c704a0500f98cd72f45d1c0caad4a59fc4c8305d8e7dce09928c31fcdbad44865d0207f53d2857c37f9f2238413f59440c00979f44b1095e2df3509e3da4bc28cff76f5540542f10ffdc92bbae4ca0eb2bbe31884fd45926dd78d1012195676430a43c91d164fde4e7297de8ed767c2884dd9b104d8fd267b814255dad1240801147f4755df71098e58dfc0c6e61f0b269fbc7238d22fda8c3515e70a88ff9e2c9ea1c66c52eb8f5d8052d2ef81a40a8b6a4d0a229bb0015e822d6cf91dce8743d2396c45f2d6029fac6b18b3b791ccc60b9ce7ed9213fbf510260cad04a4c6a943901c31c5d16760fe12f2152bb3e54908597a0497548600e578d133368ee14d90751a59692580acf3612121eeb0d6e0fe90b06cc57c64dc8d2d514b6a7388ad2552d49d0f1e0647e0e57e7fc5fdb0cacef14a1926190c3228bde6647a4abd47e228854960567d6ee263073b20738b58912754d2b80cf39dd64334eeb8b14adb47cdd569dd238562771f5a76b0238b7dab29773af8a918655553ac8a16389a2de68698636d06547ff6f0d6ad6d3b8b8cf4154567b8f53f8de0ff74f09e191478752074e68d0063aea2c1a63c8ffd1cef2bc47c83f28aa5dfb4d27d97fcb41d0f00361bd3a7ea8e486acbc8b4847cdbc1685d9149917faf159651c807cf8dc9c834ff8ef42e3532db62bfcbbf59baa61e9dd112f3e19301670b5077f334688f9c88e4091f9feb2a3b0ecab8bdd3ab03881d257cac26b35815de6ebb34f4778b2b58a66326f8f14c53c55d09beaad68f59b5bf94a567af28a2f96d5c497a887e6991b92dba459f6aa3dfabe230f504208b2c23474dbda9290ab3c308fc59e9026c10d9c3388fe938e1bba24e4aca0d091245b8a7806ebcad5fd0b5289073d40f218cb1511e22608333b9f4c966677d21e12820112148355f38c2fb59361629d7368884cfa947fb9af78d35449c90caa4e5ed6f00cb9fc7756fc64a07728e5a718a7db5e28e56a513ab5b0dae0c8a3748526761979b1f7895b1a187405bb494273a00d5bb6c2b022628a62adf78f9027c14456e53946bd9de5dba3ee0c16158e0f70eba1fa47c98f17a1604e644da2b97074d86f1c49993bda7a1523e0c6b52b6a79ba1a9c6c25226aa873fdc7e5a3b17cdc9d99e57a3dfe9af2e02b7bd6dab5e1749ccce8aaf72c12bcd5b456a2bface5d1bfcb5c50a9eaf2b93c1ec0937b6c34249c45e43734d460b229173d2dbcb9a0024d0e1b8badfcf9a4dd89e2728fa73db7f927b3ef584873f0a872591a48a5a4af3a5192e67a6321bb13bf4f03f05c6f5e905544c31f77c17116dc3195939126d859994e7e209e4d22e126eec6cd6822911798146ec663093ca1a4d1ece462f54ca4be7dda5b81ef5b4b1b368a432224bc5f0ade2eaf5bce8285f5e70df68792f2305da06a108c60327fa6e1149ac9208ad78f4f26e54ade0b55c5a9d4f0e654a30c11bad770c9aebbca9c98e68cf39931cc36fe2ae5ebf683cd55fa405e89965d192cc6f0d0eca4720eb95bdd06aad739f0e4bf5c512376e4ed7ec4c051991ce77aca3f942e09e06cafd95090934b79f188dcb2bd01a4f82144c890a2b4f8f64501f0f936468334ebfe422184915c0a8656ca4d2265bb4102d36d7a8af5a1c92fc65247d145c9a5677507a2dfab0de16abe76d2582c909db5f01561d94e50cd384a8cf72191791366b040076de27d3da19aeff189ad6e1d951770ddf954753b6bb625345af90b145e5b8632655e317c5b3548a7e77cf3ab15732a935fb4759e470f30e50c42c34db6198f88b91d3faecff06cce94e6a8aa3273f9869ad4ab57b094b07962f7f59fdc2cf1fa98d3f533f9a9336184cdfa96a49ca91d5b60292544c44c8b49b3930135ee665e77a957595a2992f87f455ba559d8ab2bb01c9594bd920dcaa796c34efc9b5c4c7214313c2af4ff780ba9f79e37474d54bc865b02eb9e91a68e2a40da2bffd8efd048bbf9232fddbf381fdea465d747a4a80fbe8ff2cce8218fa1d92de0e8ee5c0d231af19e2c402e79f0d29c98e3e85ecdea8d0e7f6e4f2f46ce5f13b95bed93c662a900a97853c028643b0d73b80852c3cea1bd4205468d1cf29f16a7be19a3c41ab610a3a0c8dc1923337df601edc02f8067061f729ad974fccd75a4cd28af9d9f864a4541044a400b909d64ddc7f8373dd3cdbcd8511afa1a1f7ba1ad8ff7338b600f2396abef1821db1cf087a6b876bb78d400ebba6ec04ac059390aae01f3788c911168a9660dd736466bde45a12c6f184647e98cb8c04b1487f2936115a886cdbad1514da043591da1e2838ea7df00316799cf119251b6c36763a7915584a592e341bfe2d47be0a621d3990fe7fdfa3c2d44fde933dacab8b6491f645f900e5cec363d2479785853ce48316c9bc17f98e26ae58d25f28e57cac8e0429563d1505164a199778ae044bc8ff3035bfc4b7da8eeb749c94320a257a379c8d01b32b2c05bb4984f640e2ee214355bcbef3e36d4b3c547c1ab6d5294acdc43a6ad4ef99715d296fc2135e7718d29a7defeee56113f1c2fc0808b9a2e180eb295274ac5509857ff9389f635919bb8f5274fb37ff5fd548939b71d456fd3a3f11812abac4adc24fe93609f5a100fd1b58638bf71dc467ac4afef436fdf48b9fbc1c1e54b26298c1439d25d04c0ed6ce8dcf2c800ed1b8035c9a41cd882f9f6dbc8f4e52b1f805f2efe0d2647dd733d344d93a92ffa80684f3326589339af43bd746032c0b271a06a87b8e4e474bcbde138706464f845d653063f0927b542413e701ae1772834ddb0d4b872489b94bb91054c9d8741e2e0ede87f86e47336745425fb9c7e83248ca4dcf4bc449a70c3a1781b221e1808f5ff17649051c8357543efed739f649599d49baffe5a8668257ea01cd41bad044739e6eaa9d1bc1b7835b85d72f17a6ac8d4b56bda873bbe940ec28123b72df363bbe8e484ebcb574c8716f105e32af6c90b341e6386ce245492fea4d1788e22a7ad8fb2a222453252301712a09cfe1de95e625dc7be17288df29fc1b6f456993baf73203517b3423a374d04588e51cf2b9d8d9661f9d28999ae45b1554522abc8c3f7f7c0a57a81fccdee9cdb39e987936241c6c9cfefa3baf487f2f09f7e0834f8bb2eeb0a3794e63d2d7102d92b34a29a654c13fd463c3df67f7cd5a2fd80c94fda130356b658c9d642fd0ac1420c3350e44e70c702745e00a06b17cf6ca68fc9a783ad989b472a39ff58f9baa37fe9ae15064bd62de1fa8d02384908e1afd73929ccd9bb79eec9ddcab01e38a3fbcd679885b471e52ff8dfe19a4300b8b670f0ac52d93556921dba7824e5960c56038ba4df7618941ba73ac234db2a6c5c1cd66e90f20f6397e79869701a883a3b50f8fedb18214473a33890c950ee2ee0ae99b0740ef73191824cabff653dad7a74dc902d68cdd9277401580d4a1264294fe2d30d061b172c78ed4f46f1cafd0fe0bc651939cbdad40f0d51c82516e5d0a7195a0e71327c8e43c982b3eb04f1ffd45740fe50db624d307a20f140100383e36ebbb65b283ae7b1d22e485df3e1a09fc2a9dd3be356cd52d4c9fb8ae2aab9fe30871a0af329574828ed1a16cb81ab1401e077913155b5f0a5748b24dc96b50f9515880cfe46d2d7e3121739dbbdb127e65dffa9ebe81d671b9e4913950e61ab3d62b3e6b678223c5f609ab076929820021458dc2025d3a495205d89d6cfbc0c07725a9c3cd6b14145bc02b39bed5a0387072bff1b0eb7aee7a4485d8aa22187732fef8966566893146b873419c977a55e6c9f7830a96360038fc3964bf713a8d0e5407b6df8b2c9063c3d11912786ba0ea1f8b95e85ef32d467e52eb55bc5a4c8427a673f10056faf6f499adcc9ebc9c58bf869c30718a3aed4f765937dcd8506767aa6aa1b8be025fbcca307a9291a16621062afd8faa2d570f1e618e5d6ff8568da5d9d0ca9a9eec1b1cee00ca7924b9f9059b77252d104e1ed393c65c184b24bb0626a5d4cdd55cbd3938140beddbc3f627af7a2f8134cc1156362342c71254d0c3fa58b86aca5a2bd9926c261c7c3cd54b0a1f6c3a66e6797adf0e1dabba635a0dcc3820a566d2bb2941fb637ee246e0e0b7c32b64ca578d38a332c0f1c0d0cc6c69674d757699bf53f707f892976b1c10ad3b2970c46909ad4baca9f3c97bd655191d69ea21f2220a88da702c9541793dbed00eba819ae2597cb4354b008ef8ea17d477a6d26bc01fda758547042d1c04ee906909dc891aa28cb4889d144b3fe9081cab4f60de2e49bf857acb4ba627f51119fe3561217f40034e119537d6738b2db692136ac4a3ecded789cf92cd801076a2c039f1a5c5ea4e46bf0cea8f07d0d3b8e40ea9208f0c7537bd6a9bf55e6384b28e44719b4ce5b6be238afd5f5b53cdef322c69b00b5c65923cb15773c9ed5fa9f0721ec684db0730e1b05db729a60194f40bfb8d0b9d0f10989c7f5f82d338d10e895f27a2958679f8ad47300e2d1408e005b821b53894b5403cc965fe456555f80f1f849dc290fb2073f28efff7291d6c47d5c3620e72798847e24d1ccbc016a8c885969a3ba727097515b719b4cc6bc6b8560f52392b12ff5ec96cf7252881d8340af6ad662e1de851e2f2fdf562edc0abbbb6aa69d13b59dbe84ee3b5407db827861b6b0154766fb7df79cc689141a5e133a953fbb03c10744392d5625c8f3351b30c408206467470d00aeb55ebc318579b56cee9c2cb66c9e5dcf1c0f8aaa6d5367271bbbb88199a1e6358d154d0ba04861d74b7b1ef3dfefbf5356f7875330afd853ac75788bb0d50363003d9601ae2277e08b76ae32baf9a635c28518bd5d17b507958d1c7669dae36e3364456711832fe2dc9757cc36e44e3e15086a72d6ec82244f125a160d9363b96e3b31cf2af7d7182442c18c85ee1d71bc97fa69cd90f6c6c9d701e067542f0d8f2bbde0a81aaa438bd9b24f7fd4c3b5a4757e76f45c2711e7e774493ca7f0cd2876018c8040b09a49d49689c43908a93d01829b0ca754d54b45495ec47aab46b6a7057dd1e07c3c6582f7631c0286612253924ee1f3614ea0a5e4f614e7cdc186e320db63573dbea5a94f68e36b0fa62c45b31d1af92afb7b0aa6371b1ac6420eaf7e5b9f387789d6aec45477e4d3e9bb1b118c4424c273123850cfed050ed3876864815a2fed52d22a57701924c74d041fd318ab7ab93d463d3ee20bf16de0b10657553b39a5129dc1ebc4e6bdcdd94cc911c8ea5e11a1d8e5b8505efb07d397e0c7bdf62eb1dfbcb981a9e7710575a92bcd576efd8683f65c8b10dc382c26ce527476cea2640607defd35cb50294e3df9693acc4fa3de03b8e5480568c2c96b7b1282227b1971ca3dd1e40da954cf45323d9dd5cef129bf7742ab746847743cdf556c5b04c6f2344352aaf307851c9f1573df93972f9ee27f39ffeb8d7ee301356ff04d296510adbed0ec5915256cb7dc9a1f372c4b1b465932da4f2df5e427ab74554f5fdfed19372ac0ee935b11b95629ac3bfedbdd9bfad37aa403309d4758a8f76e10cad3bc8a8fb66bcbf7e7cca9183211467f093c15158f3c860b013265cc6f3c985dd5b9acc8c49c1c3b8cd8f069692c086191fee1640b7769693a66ac3cb24f87a8c986951020222d34de3bfa88db7f038052e1005b58824a7145412709ac52eaa7d10f3620cc5e39f819558a85bda03db78c8f06cea3a2340f04d6b9cded7304c4dbd4cc125d1da8bbd6de99727e699bacf680dea4e1b3bf217a18294c6f4502aef73ccccf22c797d0009448b64fc85eb37c802074924506eb40575a54cb4de4f4a8f332f6b5011069b6973ca55f4ee5fd065b0b2d0381688a0baa0979662b5b27a0b5b0691334270e26655f060d0e23b5b0c822304cfc9ff7caa8eec44dea300f01fc252ef89e70e95ca8beaaa112c56042c9927c9d016009ed2ffd38cc741e06047cc5fdccb7da916fee15b1b93fd1cc77d4ec8d5bce259a4cd74afda235643f8ed1d18d7ba7003deb2f679378431288352447dae4e9588414281f192153e6bd3a899d3d04d34cfdef90d49f6b497fd4c52d59a8a6c6839ff1703b4442cd22ac02dc71be11cb6b049d859aefe59e47f1f620c022e81fc1f24ae8e49af756a28afac57b484b54f70859501f89478af76bbb83bc1c441dc82f2bc58a28cdf9db2917418e4e701df01aae7faacf4d815244f2eab6f853c2650e6059d1ca30d196be2e8f35e65dce7d3c4a28b1ce9e304675db4c0d40a40023abc5dee4bdeac6ab84928ea56b867a005a011fd39ff2c8ecfdb950de135cdb0fd775ae0944a09c3d662b6e5d83c747c717e28aaecc4fe0c109f5aa356fea858588b9a170d5ab68e6f86574c3bc6d123952f3eb41cf949d28c10b239d61cdf8840459709779b985301337f07c76e7059534da83ee5e8b7d3f94d179d6e697f99e9ab496a14326f5575bf0d6dcabea5825d5bf6827a1c926ea5b727e1f41f14011e30a8a7169b1ae769e4f9724572b5a5da3f77d9be45c5e6fd663b2d19e1dce2eff62687f5b55c616327c450950a517b159ca385df65e060827f3fe5ab104b2458ae36212c6e26ad6fcd8cd8aa4ff396e4b73b4d0f0efb15906c3bab8859397fd70dae4006dd51d2d7539f3acc98c65f3c31e531ddd6245e161f74f6c6d2337666597894d1fa92c3d7ce8e8948697c88744ec4556d8248ce4a98c99ab91f31b78d490bc29fc6bfe60554685eb13ef86879f0fe93e1a26214d04ae3884ae9f01a06ad4bae1f89a1da389b3127a5202ee1e4a76be98d4a8672521d4d18df911b52b79516685935bc77e47c138853f132234fae2a665990bc09f8f7edcda28438a3788090db3c7f11b49bf2704020a726a77a80886592be196449cbd2af0c656937fa13f8794f0bbd6d712d1571993e41674fa426627362305336a33b9043d8b6e13994b6baa036a07516563cb684b934f8911ec8078246ab1eb398d6436a6dbc35dbc84be6655230954a251f6fb6e5e2901f680b23d95c61cb17dfc80ad065c9764d84fd4d9a3a57dc292e926f0582c4350c71c89c176022fd2254abfe59e93fa79eff0899be53a1b57b53a1d6559b5570218656f7b81f92e0d071a1ad66e00f2047ebb4d1bb31dc99f2cf8ac3f6c4549616f0bdf1351806720debad080252d7d1696eab60934f57b29f6163015683f49cf4478232f3efdf196bca77015472b12a4e91f0295f2680dda3ba8bfc987e9393529d59c2d7d05186f458bcdd8e83f9906435373ddf6ca9527174058e126d72e4c4e92a846b90f320c8cb5b7158e38f510090296317a063ea5e3f9c19a7cdb1f6b72156fb8a021bcf00ea4f5210bca1ba490495421f1adbe653e4d54dbbc5e541cb5ed8f4b110ec8585a3b1cdfbf953b9ffad3b2c512d2be77a13a03f82a9207f30a2f5cdffbe085e8b94e7992ed0bd973b446c8e9ca383bd5237e1bdf6d426c312d7ae80d1192183f2729b8a44e0b30f296dceab341b419097c9e290edb45fab4ecfee96599371b3d4fbc7a74478ad88d7ae952bc57409e17a8b2efff4119ff880cef73292b2febf130e311d87f4a1142632e70f7f78d690cf7a32abb0b3c729c24ef0568dc6946228193c11bd5879652a7d094308fa792ffee962120fb65f5ac4d03b582722e5b63ed232d68909269fb693a088bdea0f5f1712bb0f46220c05d9165f0f99d7bc036ba67ec3e89573cfcd103623d0fc8253df5b59a8ca2b48cc706ff0d2ac0cf6defc8af727fa915865e3aa0ebbe7a83a31ed73fd099255d58d42ee7b655df155746e424407a879bfca2266eb963575f58534a7baf5e630e643aa13164104c00727885f7426c67b0fb72cf5b118d074d630321be5878f0ee5b949bac46fdd18436fef519a55f72cc2bbe1ec9f40b6e8d5e6b217d1fdf9265d2e5a20aeb6fd6411d802bcc5816819c64074a1b7f609bc36f126c36914c80dcb6a0edb6fbaf7d5d143b9d026715b8f2b42c457abac0eaf7e44c1142c30e275116a7be36606e7723e436659459936cc68c3fa8651afca5b7a50a9a2bb4ba5d4c20e0abced8a93f0f355a85f4ec54f0ae652798908dc039fddf43fe0ec5c8b392c2c26e27474ca44fef38ab10efeac73130660b97daf6cf30c3e6d61f9d75354447ff3c641435c195e4409d072a17acef3013eb8d15ab0dde2e2d682323e547abb6d60ae605c20887d5a4398830f33383f109dcf179619fdc18d42471b26752de31b3e2ad40bd52bc5269a15090a60f1807b97538153ccf07fc93a5cc4873e1c519a8680208f4c39534cba7c4f393726148bc96e353038e4d035d1804ddcdee974748ebd938319b9424ebbdd70032cd34743de2cdb8ce89fa3a6e70fce6fc2d33dfcb443c2b65ed83a0e7c54eb3131651038c7b995673c89f4c92973958918a62820e60b951ae96eadc0cae2c4677c2b0374774bb5cbf4d0dbecfb7b524a64a078d37d605afdc01d1530f6507ddd9acdad8f9dcee2536ac76d74dc52f2bdb4ec5a13c41f7e2f6d2de33a2bcbcc05331da8ac36c8c11eb32c5a4e0bd59b67d1a195d62266ea34e990e85fa7c8638e4bb626f0e0d8400a6adb51df4a7d15c65fcbf464fbcb84adb39c2832bd637419145e49c6c5ace7bc4dee5737e320abe3f26ebdfcf1a65da56f20834dd5f15c9d3d61f59a2bfb0f95f1104b044df8f38581b0c431b3005240fc497ffd6797ae70e375f3c75d6cbf5ce0501a6aa37442c4ae8d07f4d5525545e47a31b29991dbcd43dd8d3ab848ee24576471e38e8e4cde0dc099ac2ba0d298a77f895c81121317454a2bc406be1ccb6ebc23518bce7ab55a28611b636a33cc29b2a8cab2d5cbdfea6f37c571a5d448aad2d04271b2c8db24faae3dd0bf9cc32685eab08ceb5054a2f7ded7c328428c39de22d7875ee60d37fd48a31ecc7d4e020de6750d6600c29220bbab78b258","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"11e2c82699f0c5f21a813151810d18ae"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>